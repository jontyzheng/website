/*
 Navicat Premium Data Transfer

 Source Server         : jonty
 Source Server Type    : MySQL
 Source Server Version : 50733
 Source Host           : localhost:3306
 Source Schema         : blogdb

 Target Server Type    : MySQL
 Target Server Version : 50733
 File Encoding         : 65001

 Date: 17/05/2021 15:55:43
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for post
-- ----------------------------
DROP TABLE IF EXISTS `post`;
CREATE TABLE `post`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `tag` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `title` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `profile` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `body` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `date` date NULL DEFAULT NULL COMMENT '发布日期',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 65 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of post
-- ----------------------------
INSERT INTO `post` VALUES (28, 'Java', '配置 MySQL5.7', 'MySQL5.7安装指南', 'vvv', '2021-05-16');
INSERT INTO `post` VALUES (29, 'js', 'JS00-消失按钮', '使用js擦去按钮', '# JS00-消失按钮\r\n\r\n[TOC]\r\n\r\n### 案例: 擦去一个按钮\r\n\r\n##### 一. html( 2 个按钮)\r\n\r\n##### 文件1-1: 消失一个按钮-make-button-dispear.html\r\n\r\n```html\r\n<input type=\"button\" value=\"无辜的按钮\" id=\"tarBtn\" style=\"display: block;\"/>\r\n<input type=\"button\" value=\"消失它\" id=\"wipeBtn\" onclick=\"eg.wipe()\" />\r\n```\r\n\r\n#### 二.js\r\n\r\n##### 文件2-1: make-button-dispear.js\r\n\r\n```js\r\nvar eg = {}\r\n\r\neg.$ = function(id) {\r\n    return document.getElementById(id);\r\n}\r\n\r\neg.wipe = function() {\r\n    //第一种方法: \r\n    eg.$(\"tarBtn\").style.visibility = \'hidden\';\r\n    //第二种方法:\r\n    eg.$(\"tarBtn\").style.display = \'none\';\r\n}\r\n```\r\n\r\n\r\n\r\n#### 2 种方法的对比\r\n\r\n第一种只是修改元素的\"visibility\" 属性, 元素本身仍然在那.\r\n\r\n第二种是修改元素的\"display\"属性, 一个元素的\"display\"属性为\"none\"时相当于完全消失, 不占任何空间.\r\n\r\n所以前一种是按钮 1 消失, 但仍然空一块, 后一种是按钮 1 消失 , 原来排在按钮 1 下面的按钮 2 代替按钮 1 的位置.', '2020-02-02');
INSERT INTO `post` VALUES (30, 'Java', '水仙花数', '添加一条简介', '# other-水仙花数\r\n\r\n### 一.概念\r\n\r\n水仙花数（Narcissistic number）\r\n\r\n也被称为超完全数字不变数（pluperfect digital invariant, PPDI）、自恋数、自幂数、阿姆斯壮数或阿姆斯特朗数（Armstrong number），\r\n\r\n水仙花数是指一个 3 位数，\r\n\r\n它的每个位上的数字的 3次幂之和等于它本身（例如：1^3 + 5^3+ 3^3 = 153）。\r\n\r\n[摘自百度百科]\r\n\r\n给定一大一小 2 个整数作为一个整数区间, 求这个整数区间内的水仙花数.\r\n\r\n\r\n\r\n\r\n\r\n### 二.题解\r\n\r\n#### 刀削面法\r\n\r\n把一个数各个位数上的数字一个个削下来, 计算三次方然后累加起来, 最后和原来的数字对比.\r\n\r\n\r\n\r\n##### 过程中可能会遇到的问题\r\n\r\n- 如何将一个比如三位数, 把各个位数上的数字拿下来.\r\n\r\n余十除十法:\r\n\r\n以 125 举例, 先将 125 余十, 得到的就是 5. 这样, 每次作余十运算, 总能得到个位数, 也就是不能被 10 整除的数字.\r\n\r\n接着, 将 125 除以十. 也就是缩小十倍, 剔除个位, 得到 25. 这样, 每次对十做除法, 总能剔除掉十位数. 得到剩余的位数上的数字.\r\n\r\n\r\n\r\n### 三.代码实现(Java)\r\n\r\n```java\r\npackage leet.calc;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * @name  FlowerNumber\r\n * @layer leet.calc\r\n * @intro\r\n * @function\r\n * */\r\npublic class FlowerNumber {\r\n	public static List<Integer> findFlower(int n, int m) {\r\n		List<Integer> list = new ArrayList<Integer>();\r\n		\r\n		for (int i = n; i <= m; i++) {\r\n			int temp = i;	//	取出 i\r\n			int res = 0;\r\n			while (temp > 0) {\r\n				int val = temp%10;\r\n				double tVal = Math.pow(val, 3);\r\n				res += tVal;	//整数的指数还是整数, 所以不影响结果\r\n				temp/=10;\r\n			}\r\n			if (res == (int)i) {\r\n				list.add(i);\r\n			}\r\n		}\r\n		return list;\r\n	}\r\n	public static void main(String[] args) {\r\n		int n = 152;\r\n		int m = 500;\r\n		System.out.println(findFlower(n, m));\r\n        //[153, 370, 371, 407]\r\n	}\r\n}\r\n```\r\n\r\n另外, 如果题目要求返回一个整型数组的话, 分享一个冷门的方法.\r\n\r\n```java\r\nint[] a = list.stream().mapToInt(Integer::intValue).toArray();\r\n```\r\n\r\n\r\n\r\n', '2021-05-16');
INSERT INTO `post` VALUES (34, 'css', 'CSS-选择器', 'CSS-选择器', '# CSS-选择器\r\n\r\n[TOC]\r\n\r\n### 格式\r\n\r\n一条 CSS 规则 = 选择器 + 声明块\r\n\r\n```css\r\nh1 {\r\n    color: red;\r\n    background-color: yellow;\r\n}\r\n```\r\n\r\n声明块 = 属性 : 属性值. \r\n\r\n多个声明之间用 `;` 隔开. 最后一条的 ; 可加可不加(推荐加上, 方便样式的补充)\r\n\r\n\r\n\r\n### 选择器\r\n\r\n当多个元素应用相同一组样式时, 多个选择器之间用 `,` 隔开\r\n\r\n```css\r\nh1, h2 {\r\n    color: red;\r\n}\r\n```\r\n\r\n\r\n\r\n### 声明块\r\n\r\n声明块 = 属性 : 属性值\r\n\r\n有些属性不止一个属性值, 比如说给一组文字加上边框线\r\n\r\n边框有 3 种属性值 - 边框线粗细, 边框线类型, 边框线颜色.\r\n\r\n多个属性值之间用 空格 隔开\r\n\r\n```css\r\nh1 {\r\n    border: 1px solid red;\r\n}\r\n```\r\n\r\n\r\n\r\n 以上基本就是 CSS 格式的所有内容了. 之后可以正常写一些常见的 CSS 了.\r\n\r\nCSS 的应用见 CSS-style.', NULL);
INSERT INTO `post` VALUES (35, 'js', 'JS00-摘要', 'JS00-摘要', '# JS00-摘要\r\n\r\n\r\n\r\n#### 1.冷却/唤醒一个按钮\r\n\r\n```js\r\neg.$(\"tarBtn\").disabled\r\n//将 disabled 属性设置为 true/false 时按钮冷却或唤醒\r\n```\r\n\r\n#### 2.消失一个元素\r\n\r\n```js\r\neg.$(\"tarBtn\").style.visibility = \'hidden\';\r\n```\r\n\r\n\r\n\r\n', NULL);
INSERT INTO `post` VALUES (36, 'js', 'Boolean', 'Boolean', '## Boolean\r\n\r\n[TOC]\r\n\r\neditTime: 2021年2月10日1h\r\n\r\n\r\n\r\n#### 代表\r\n\r\n逻辑判断类型\r\n\r\n值: true & false \r\n\r\n### 表示形式\r\n\r\n布尔值只认小写. True, False ∈ *标识符*.\r\n\r\n```js\r\nvar hasApple = true;\r\nalert(typeof hasApple);	//	boolean\r\n```\r\n\r\n\r\n\r\n\r\n\r\n和 1 和 0 等价(Java 不可)\r\n\r\n##### 如: true等于1\r\n\r\n```js\r\nalert(true == 1);	//	true\r\n```\r\n\r\n> Java 中会提醒 \"==\" 操作符不适合应用在 int 和 boolean 上.\r\n\r\n\r\n\r\n如果用 equals 方法的话, 因为 equals 是对象方法, 所以要把 boolean 类型改成 Boolean, 参数类型因为是对象类型, 所以参数可以是任何类型.\r\n\r\n用 true 的对象判断是否 equals 1 的时候结果是 false\r\n\r\n```java\r\npackage com.jt.practice.type;\r\n\r\n/**\r\n * Java 中不存在 布尔值和 01 互转的.\r\n * @author Jonty Zheng\r\n */\r\n\r\npublic class BoolNum {\r\n    public static void main(String[] args) {\r\n        Boolean result = false;\r\n        //System.out.println(result == 0);\r\n        System.out.println(result.equals(\"0\")); //  false\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 万物皆可布尔\r\n\r\n> Boolean() \r\n\r\n| 数据类型  | 转成 true      | 转成 false |\r\n| --------- | -------------- | ---------- |\r\n| Boolean   | true           | false      |\r\n| String    | 任何非空字符串 | \"\"         |\r\n| Number    | 非0非空        | 0 或 NaN   |\r\n| Undefined |                | undefined  |\r\n\r\n\r\n\r\n```js\r\nvar msg=\"hello\";\r\nalert(Boolean(msg));	/*true*/\r\n\r\nvar text = \"\";\r\nalert(Boolean(text));	/*false*/\r\n\r\nvar num = 16;\r\nalert(Boolean(num));	/*true*/\r\n\r\nalert(Boolean(0));		/*false*/\r\n\r\nalert(Boolean(null));	/*false*/\r\n\r\nalert(Boolean(new String()));	//	true\r\n```\r\n\r\n\r\n\r\n> 备注: Boolean()  的方法判断, 当参数为 `\"\"` 时: false; 当参数为 `null` 时: **true**.\r\n\r\n\r\n\r\n\r\n\r\n> ps *js 中神奇的自动转换机制*\r\n>\r\n> ```js\r\n> var msg = \"hellow\";\r\n> undefined\r\n> if (msg) {\r\n> alert(\"Value is value\");	/*Value is value*/\r\n> }\r\n> ```\r\n>\r\n> 对应前面的自动转换. 非空字符串被自动转成了 true.\r\n\r\n', '2021-04-20');
INSERT INTO `post` VALUES (37, 'Java', 'typora输入数学公式', '输入数学公式', '# 用 typora 输入数学公式\r\n\r\n[TOC]\r\n\r\n#### 符号\r\n\r\n前提步骤: 在 `偏好设置` 中打开 `内联公式`\r\n\r\n`$$...$$` 公式块\r\n\r\n`$..$`	 行内公式\r\n\r\n\r\n\r\n\r\n\r\n#### 1.分数\r\n\r\n> `\\frac` 分数起始符\r\n>\r\n> `{}{}` 后跟 2 个花括号作为参数\r\n\r\n$\\frac{1}{2}$\r\n\r\n(双击可查看源码)\r\n\r\n\r\n\r\n\r\n\r\n', '2021-05-16');
INSERT INTO `post` VALUES (39, 'Python', ' part01-安装flask环境', ' part01-安装flask环境', '# part01-安装flask环境\r\n\r\n[TOC]\r\n\r\n[参考文档](http://docs.jinkan.org/docs/flask/installation.html#installation)\r\n\r\n\r\n\r\n### 一.使用 pip 安装virtualenv\r\n\r\nvirtualenv (虚拟环境), 一个会自动处理库版本兼容的东西.\r\n\r\n任意新建一个文件夹, 并在当前目录下打开命令行【右键以管理员身份运行】, 输入以下命令:\r\n\r\n```\r\npip install vitualenv;\r\n```\r\n\r\n#### 结果\r\n\r\n```\r\nSuccessfully installed appdirs-1.4.4 distlib-0.3.1 filelock-3.0.12 importlib-metadata-3.4.0 importlib-resources-5.1.0 typing-extensions-3.7.4.3 virtualenv-20.4.2 zipp-3.4.0\r\n```\r\n\r\n### 二.激活virtualenv\r\n\r\n##### 2.1.创建项目, 创建 venv 📂\r\n\r\n新建 xxx 文件夹, 运行 `virtualenv venv` 创建一个 venv 文件夹\r\n\r\n```py\r\nD:\\code\\PycharmProjects>xxx>virtualenv venv\r\n```\r\n\r\n显示\r\n\r\n```\r\ncreated virtual environment CPython3.6.5.final.0-64 in 408ms\r\n  creator CPython3Windows(dest=E:\\WeChatProjects\\mini-action\\venv, clear=False, no_vcs_ignore=False, global=False)\r\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, wheel=bundle, via=copy, app_data_dir=C:\\Users\\32079\\AppData\\Local\\pypa\\virtualenv)\r\n    added seed packages: pip==21.0.1, setuptools==52.0.0, wheel==0.36.2\r\n  activators BashActivator,BatchActivator,FishActivator,PowerShellActivator,PythonActivator,XonshActivator\r\n```\r\n\r\n可以看见的是: \r\n\r\n新增了 venv 📂. 该文件夹下有 2 个文件夹(Lib+Scripts)和 2 个文件( .gitignore  │  pyvenv.cfg)\r\n\r\n该文件夹便是存放环境配置文件的地方.\r\n\r\n> ps: venv 只是一个装配置文件的文件夹名称, 你可以改成任意你想要的名字\r\n>\r\n> 比如说 virtualenv flask 就会创建叫做名字叫做 flask 的文件夹.\r\n\r\n##### 2.2.激活vitrualenv\r\n\r\n```\r\nvenv\\scripts\\activate\r\n```\r\n\r\n实际上试运行 scripts 文件夹下的 `activate.bat`\r\n\r\n此时控制台会跳进 (venv) 环境中\r\n\r\n```\r\n(venv) D:\\code\\PycharmProjects>   \r\n```\r\n\r\n前方显示当前活动的环境 `(venv)` 则表示当前命令行运行在 virtualenv 的环境当中了. \r\n\r\n\r\n\r\n### 三.使用 pip 安装flask\r\n\r\n```py\r\npip install Flask\r\n```\r\n\r\n执行\r\n\r\n```\r\nCollecting Flask\r\n...\r\nInstalling collected packages: MarkupSafe, Werkzeug, Jinja2, itsdangerous, click, Flask\r\nSuccessfully installed Flask-1.1.2 Jinja2-2.11.3 MarkupSafe-1.1.1 Werkzeug-1.0.1 click-7.1.2 itsdangerous-1.1.0\r\n```\r\n\r\nFlask安装完毕\r\n\r\n### 四.验证是否安装成功\r\n\r\n导入flask模板\r\n\r\n```python\r\n>>> import flask\r\n>>>\r\n\r\n```\r\n\r\n如果语句没有报错, 就说明Flask安装成功\r\n\r\n\r\n\r\n## 记录\r\n\r\n##### Flask ImportError: No Module Named Flask \r\n\r\n###### 源头\r\n\r\n未检测到 flask 环境(pip安装flask的时候没有用管理员权限安装)\r\n\r\n###### 已解决\r\n\r\n使用**管理员权限**运行命令行再 pip install flask\r\n\r\n删除 venv 文件夹, 运行 virtualenv *flask* (生成名为flaks文件夹)\r\n\r\n[参考](https://stackoverflow.com/questions/31252791/flask-importerror-no-module-named-flask)', '2021-04-20');
INSERT INTO `post` VALUES (40, 'Java', 'Java01-理解面向对象', '', '# Java01-理解面向对象\r\n\r\n\r\n\r\n### \"多态封装并继承\"\r\n\r\n> 巧计: \"有一个人要求主人堕胎(多态), 接着把自己打包(封装)放到主人家门口, 然后继承主人的家产\"\r\n\r\n\r\n\r\n\r\n\r\n', '2021-04-26');
INSERT INTO `post` VALUES (41, 'Java', 'Java02-数据类型', '', '# Java02-数据类型\r\n\r\n[TOC]\r\n\r\n## 命名\r\n\r\n概念: 用于给程序的类, 变量, 方法命令的符号.\r\n\r\n1.由 **2 种类型**和 **2 个符号**组合: 类型是数字和字母, 符号是 `_` 和 `$`. (其中不能是 数字 打头);\r\n\r\n> 如果说, 在本地作算法题时, 是不能用题目序号作为类名开头以区分的.\r\n\r\n2.字母: 这里的字母包括{26 个英文字母, 中文字符, 日文字符, ...}\r\n\r\n3.java 8可以用单独一个 _ 命令, 但 Java 9 不允许.\r\n\r\n\r\n\r\n\r\n\r\n### 强类型语言\r\n\r\n1.变量必须先声明后使用\r\n\r\n2.执行类型的变量只接受类型匹配的值\r\n\r\n> js 是一门弱类型的语言\r\n>\r\n> 1.同一个变量, 声明后可以先后赋不同类型的值(弱类型, 不严密)\r\n\r\n\r\n\r\n#### 引用类型\r\n\r\n```\r\n引用类型包括\r\n类, 接口, 数组, null \r\n```\r\n\r\n\r\n\r\n\r\n\r\n## Java 的数据类型\r\n\r\n```\r\nJava 中的数据类型分为\r\n基本类型和引用类型两种\r\n```\r\n\r\n\r\n\r\n### 8 种基本类型\r\n\r\n1 种非数值型 & 7 种数值型\r\n\r\n```\r\nboolean\r\n\r\nbyte\r\nchar    short	\r\nint		long	\r\nfloat	double\r\n```\r\n\r\n\r\n\r\n#### 〖数值型〗\r\n\r\n```\r\n数值型又分为整数和小数\r\n其中整数中有\r\nshort int byte char \r\n小数有\r\nfloat double\r\n```\r\n\r\n\r\n\r\n##### 整型\r\n\r\n`byte`: 在计算机中的内存有 8 位, 装得下 $-2^7$ ~ $2^7-1$ 之间的数值;【-128, 127】\r\n\r\n`short`: 在计算机中的内存有 16 位, 装得下 $-2^{15}$ ~ $2^{15}-1$ 中间的数.【-3,2768, 3,2767】\r\n\r\n> short 上可装 **3w**+ 的数字, 下可以装 **-3w** 的数字\r\n\r\n`int`: 最常见的整数类型, 在计算机里有 32 位的内存, \r\n\r\n可以装得下的数值在 $-2^{31}$ ~ $2^{31}-1$ 中间的数字\r\n\r\n> int 可以下装 -21,4748,2348, 上装 21,4748, 32347. 离数轴原点两边 **21亿** 多的数字都可以装.\r\n\r\n`long`: 最长的整数类型, 在计算机里有 64 位的内存, 装的数字也最多, $-2^{63}$ ~ $2^{63}-1$ \r\n\r\n\r\n\r\n默认整数类型 int, 如果一个整数足够大, 超出了 int 的表示范围, 在结尾加上 L 或者 l, 才会被当作 long 类型处理.\r\n\r\n\r\n\r\n\r\n\r\n小疑问大课堂\r\n\r\n```\r\n问: 拿 byete 举例, 为什么明明有 8 位, 能存的指数却只有 7?\r\n\r\n解释: 因为假如说要 2^8 的话, 是不是是 1 后面有 8 个 0 才能叫做 2^8, 那样的话至少需要 9 位吧. 1 个 1 8 个 0.\r\n现在有 8 位肯定都拿来放 1 了, 空间最大化利用, 怎么都要差 1 个才能达成 2^8. \r\n\r\n而这里又有一个巧妙的地方:\r\n实际上, 全部用来放 1 并不是\"资源最大化\"的最佳选择.\r\n因为要表示正负数, 第一个是符号位. 0 正 1 负.\r\n所以第一位如果当 1 的话, 会被识别成 1 个负数.\r\n实际和数值绝对值相关的只有后面 7 位.\r\n所以如果要想 byte 资源最大化的话, 第一位放的应该是 0 而不是 1.\r\n```\r\n\r\n\r\n\r\n**小课堂: char 也属于整数类型**\r\n\r\nchar 也被叫做整数类型, 这是因为 char 变量既可以被赋予字符值, 也可以被赋予整数值.(Java 强类型我们知道, 一个值只能被赋予给对应类型的变量, 由后者易知, char 属于整型)\r\n\r\n本质: 当被赋予整数值时, 该字符变量会把这个整数值识别成字符的 ASCII 码值, 最终结果也是一个字符了.\r\n\r\n如文件1-1: CharToInt.java\r\n\r\n```java\r\npackage chap3.no5;\r\n\r\n/**\r\n * @name  CharToInt\r\n * @layer chap3.no5\r\n * @intro 	char 类型有哪几种值类型\r\n * @function 说明 char 也可以赋予整数值\r\n * */\r\npublic class CharToInt {\r\n	public static void main(String[] args) {\r\n		char a = 48;\r\n		char b = \'a\';\r\n		System.out.println(a); 	//0\r\n		System.out.println(b); 	//a\r\n        \r\n        //其它形式的字符\r\n        char c = \'\\n\';			\r\n		System.out.println(c);	//\r\n		char d = \'\\u9999\';		//香\r\n		System.out.println(d);                \r\n	}\r\n}\r\n```\r\n\r\n\r\n\r\n**关于转义字符(char)**\r\n\r\n如文件1-2: SpecialCha.java\r\n\r\n```java\r\npackage chap3.no4;\r\n\r\n/**\r\n * @name  SpecialCha\r\n * @layer chap3.no4\r\n * @intro	Java 中的 3 个特殊字符 \' \\ \"\r\n * @function	要表示这几个特殊字符需要特殊的方法\r\n * */\r\npublic class SpecialCha {\r\n	public static void main(String[] args) {\r\n		//转义字符的地方: \r\n        String src = \"d:\\\\code\";	\r\n        \r\n        //两个\\\\实际上只会打印 1 个\\\r\n		System.out.println(src);	//d:\\code\r\n		\r\n		String cc = \"\\\'\";			\r\n		//\\加单引号实际上只会打印 1 个单引号		\r\n		System.out.println(cc);		//\'\r\n		\r\n		String gang = \"\\\\\";			\r\n		//杠加双引号会触发不完整⚠\r\n		System.out.println(gang);	//\\\r\n	}\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n**整型的福利**\r\n\r\n`switch-case` 分支判断只接受 5 种整数类型和字符串(以及枚举类型).\r\n\r\n> 不接受 布尔型, 浮点型.\r\n\r\n即字符串, 整数型, (字符型)都可以使用 `switch-case` 进行分支判断逻辑.\r\n\r\n\r\n\r\n**整型的第一种表示方式**\r\n\r\n文件2-1: ByteInt.java\r\n\r\n```java\r\npackage chap3.no4;\r\n\r\n/**\r\n * @name  ByteInt\r\n * @layer chap3.no4\r\n * @intro	五大整数类型变量的声明\r\n * @function	只接受在范围内的变量值, 其中 long 需加 L 后缀(因为 Java 默认识别成 int)\r\n * */\r\npublic class ByteInt {\r\n	public static void main(String[] args) {\r\n				\r\n		byte b = 127;\r\n		//byte b = 128;	 - cannot convert from int to byte\r\n		\r\n		short s = 32767;\r\n		//short s = 32768;	- cannot convert from int to short\r\n		\r\n		int i = (int) (Math.pow(2, 31)-1);\r\n		//int i = 2e32;	cannot convert from double to int\r\n		\r\n		long l = 999999999999999999L;	/* 加L */\r\n		//long l = 999999999999999999;	- The literal 999999999999999999 of type int is out of range \r\n		\r\n		char c1 = \'c\';\r\n		char c2  = 48;			//0\r\n		System.out.println(c2); 		\r\n		\r\n	}\r\n}\r\n```\r\n\r\n\r\n\r\n**整型的第二种表示方式(非十进制)**\r\n\r\n除了在范围内按部就班地, Java 的整数值的另外 4 种表示形式\r\n\r\n```\r\n二进制	0b101	0B101\r\n八进制	077	\r\n十六进制	0xEE	0Xee	(不区分大小写)\r\n\r\n```\r\n\r\n文件3-1:  ZhengII.java\r\n\r\n```java\r\npackage chap3.no4;\r\n\r\n/**\r\n * @name  ZhengII\r\n * @layer chap3.no4\r\n * @intro	低到高\r\n * @function 	高到低超范围, 低到高自动转(本质取决于内存空间)\r\n * */\r\npublic class ZhengII {\r\n	\r\n	public static void main(String[] args) {\r\n				\r\n		//int2\r\n		int i2 = 07;				//7\r\n		System.out.println(i2);\r\n		\r\n		//int3\r\n		int i3 = 0XF;\r\n		System.out.println(i3);		//15\r\n		\r\n		//int4\r\n		int i4 = 0B100;\r\n		System.out.println(i4); 	//4\r\n		\r\n	}				\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**基本数据类型之间的互换**\r\n\r\nps: 不包括布尔类型.\r\n\r\n**char - int**: char 和 int 互换得到的整数值对应地址的字符\r\n\r\n内存容量小到大, 自动转; 大到小, 需要强转.\r\n\r\n高到低, 如上(ByteInt.java), 如果过大, 程序会显示内存空间超过范围, 右边的值超出指定类型的变量的内存空间.\r\n\r\n文件4-1: AutoChange.java\r\n\r\n```java\r\npackage chap3.no4;\r\n\r\n/**\r\n * @name  AutoChange\r\n * @layer chap3.no4\r\n * @intro	低到高\r\n * @function 	低到高自动转, 高到低超范围\r\n * */\r\npublic class AutoChange {\r\n	\r\n	public static void main(String[] args) {\r\n		//byte2\r\n		byte b = 0B1000;\r\n		System.out.println(b); 		//	8\r\n		\r\n		//低到高, byte转int\r\n		int i = 0B1000;		\r\n		System.out.println(i); 	//	8\r\n		\r\n        //低到高, int转long \r\n		long l = 8;\r\n		System.out.println(l); 	//	8\r\n				\r\n		//变量类型\r\n		System.out.println(getType(l)); //java.lang.Long\r\n		System.out.println(getType(i)); //java.lang.Integer\r\n	}\r\n\r\n	//查看变量类型\r\n	public static String getType(Object o) {\r\n		return o.getClass().getName();\r\n	}\r\n}\r\n\r\n\r\n```\r\n\r\n高到低超范围(小的能装, 多的装不下), 低到高自动转(总是装得下)\r\n\r\n```java\r\nbyte b = 8;	//所以 8 可以赋值给 byte\r\n\r\n```\r\n\r\n\r\n\r\n参考: [java获取基本变量的类型](https://blog.csdn.net/qiletaotao/article/details/87861759)\r\n\r\n\r\n\r\n**类型强转的应用——随机字符串的生成**\r\n\r\n从随机整数到随机字符, 从随机字符到随机字符串\r\n\r\n```java\r\npackage chap3.crss;\r\n\r\n/**\r\n * @name  RandomStr\r\n * @layer chap3.crss\r\n * @intro	先随机生成 6 个指定的整数, 再传成对应的字符, 接着拼接到一起组成一个随机字符串\r\n * @function	随机字符串的生成\r\n * */\r\npublic class RandomStr {\r\n	public static void main(String[] args) {\r\n		String res = \"\";\r\n		for (int i = 0; i < 6; i++) {\r\n			int intVal = (int)(Math.random() * 26 + 97);\r\n			res = res + (char)intVal;\r\n		}\r\n		System.out.println(res);\r\n		System.out.println(Math.random()); 		//0.45739820511766016\r\n		System.out.println(Math.random()*10); 	//7.014110425875772\r\n		System.out.println((char)(int) (Math.random()*10 + 98));	//j	\r\n		System.out.println((char)(int)(Math.random()+65));			//A\r\n	}\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n**小疑问小课堂: 233 强装后等于 -23**\r\n\r\n```java\r\npublic class IntToByte {\r\n	public static void main(String[] args) {\r\n		int a = 233;\r\n		byte b = (byte)a;\r\n		System.out.println(b); 	//-23\r\n	}\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n> 为什么 233 强转 byte 会得到 **- 23**\r\n\r\n\r\n\r\n```\r\n首先, 类型的强转实际上是对内存二进制数截取得到的.\r\n当高容量转换成低容量的时候, 会发生位数上削减.\r\n而通常有一个地方会容易被忽略, 就是 byte 类型实际上用于存放数值位的位数仅仅有 7 位.\r\n回到对内存中的截取中来.\r\n233, 通过计算可得到 233是128, 64, 32, 8, 1加起来的结果, 转化成二进制也就是  1110, 1001\r\n得到 233 在内存中数据时, 我们来看计算机是如何识别它们的.\r\n首先位数截取, 原来 233 拥有的容量有 32 位, 而有效数字只占用了 8 位.空闲位数都用 0 填充.\r\n而这时候, byte 过来容量截取的时候, 看到 8 位的时候也刚好, 没有\"数值损失\".\r\n8 位刚好装下了 8 位有效数字.\r\n这个时候, 依然是计算机底层中表示. 也就是\"补码\".\r\n而补码有规则: 正数的补码是补码, 但是负数的补码是正数补码取反再加一.\r\n现在得到了计算机里存放的补码, 翻译出来的时候就是走相反的过程.\r\n于是, 我们得到了这样的示意图\r\n 		1110, 1001\r\n 	   /		  \\\r\n 	 正            反码\r\n 	/				 \\\r\n  正					 负数\r\n按照右边的支线, 减去 1 得到反码后, 再取反的到原码\r\n由于计算机是以 1 开头的, 取反不改变符号位. 计算机里的负数都是以 1 开头的.\r\n所以 byte 会被识别成负数, 所以按照负数的转换.\r\n1.减去 1 得到反码 	1110,1000\r\n2.反码取反得到原码	   1001,0111\r\n3.原码等值互换得到数值	 -2^4+7=-23\r\n\r\n```\r\n\r\n\r\n\r\n大容量强转为小容量的结果\r\n\r\n```\r\n大概率会造成信息丢失\r\n就算没有丢失, 也有可能会有数值位被当作符号位.\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n**字符串&基本类型**\r\n\r\n任何基本类型的变量和字符串做拼接都会被同化, 得到字面值的字符串.\r\n\r\n如 `12L + \"-\"` 等于 `12-`\r\n\r\n应用: 想要基本类型变量的字符串表示时, 可以和\"空字符串\"拼接.\r\n\r\n\"+\"\r\n\r\n```java\r\nSystem.out.println(3 + 4 + \"x\");	//7x\r\nSystem.out.println(\"x\" + 3 + 4); 	//x34\r\n//不仅如此, 字符串还可以和char类型变量作拼接\r\nSystem.out.println(\"sss\" + \'a\');	//sssa\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n自动升级\r\n\r\n不同基本类型的变量可以进行四则运算\r\n\r\n当多个基本类型参与运算时, 最后得到的变量类型像公式内的当前最高类型转化.\r\n\r\n> 例子: `short` 类型和 `int` 的类型变量相加会得到 `int`, `double` 类型和 `short` 变量相加得到 `double` 类型\r\n\r\n```java\r\npublic class AutoSwitch {\r\n	public static void main(String[] args) {\r\n		short s = 5;\r\n		double d = 5.0;\r\n		double res = s + d;	//得到10.0\r\n		int a = 2;\r\n		int res2 = a + s;	//得到7		\r\n		//short s = sVal - 2;\r\n		//Type mismatch: cannot convert from int to short\r\n	}\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n**输出整数的二进制数**\r\n\r\n`Interger.toBinaryString(int x)`\r\n\r\n```java\r\nSystem.out.println(Integer.toBinaryString(100));	//1100100\r\n\r\n```\r\n\r\n\r\n\r\n> 知道了输出整数的二进制表示之后, 来看一看二进制是怎么表示负数的?\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nBigByte.java\r\n\r\n```java\r\n/**\r\n * @name  BigByte\r\n * @layer chap3.no4\r\n * @intro	测试二进制是怎么表示负数的	\r\n * @function	介绍输出整数的二进制的函数, 入门认识补码.\r\n * */\r\npublic class BigByte {\r\n	public static void main(String[] args) {		\r\n		int x = 100;\r\n		System.out.println(Integer.toBinaryString(x));	//1100100\r\n		//二进制是怎么表示负数的\r\n        int xx = -8;\r\n		System.out.println(Integer.toBinaryString(xx)); //11111111111111111111111111111000\r\n	}\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n\r\n二进制只有最后 3 位对得上 -8 的绝对值, 前面都是 1.\r\n\r\n\r\n\r\n##### 小数\r\n\r\nfloat 和 double\r\n\r\n```\r\nfloat\r\n第一位符号位, 中间 8 位指数位, 接 11 位尾数\r\ndouble \r\n第一位符号位, 中间 11 位指数位, 接 52 位尾数\r\n\r\n```\r\n\r\n###### 小数的福利: 科学计数法\r\n\r\n只有浮点数可以用科学计数法\r\n\r\n$5.12e10$ 表 5.12×$2^{10}$\r\n\r\n$512E10$ 属于浮点数.\r\n\r\n```\r\n默认浮点数类型 double, float 类型需要在结尾跟上 F 或 f. \r\n(和隔壁整数家的 long 哥们情况差不多)\r\n不同的表示不同的内存空间\r\n5.12 表示 double 类型的数字, 在内存里头有 64 位的空间\r\n5.14F 表示 float 类型的数字, 在内存里有 32 位的空间\r\n\r\n```\r\n\r\n\r\n\r\n**印非尼迪**\r\n\r\n其它 **3** 个特殊的浮点值.\r\n\r\n```\r\nInfinity 正无穷大 只有浮点运算才能得到这个值\r\n-Infinity	负无穷大 同理\r\n\r\n```\r\n\r\nJava 中也不是运算 0 作除数的(在隔壁家是这样)\r\n\r\n```java\r\nSystem.out.println(4/0);\r\n//Exception in thread \"main\" java.lang.ArithmeticException: / by zero\r\n\r\n```\r\n\r\n非数\r\n\r\n```\r\nNaN	非数 等于 0 的小数除以 0 会看见的结果\r\n\r\n```\r\n\r\n\r\n\r\nBossPoint.java\r\n\r\n```java\r\npackage chap3.point;\r\n/**\r\n * @name  BossPoint\r\n * @layer chap3.point\r\n * @intro 3 个特殊浮点型\r\n * @function\r\n * */\r\npublic class BossPoint {\r\n	public static void main(String[] args) {\r\n		double res = 4.0/0;			//Infinity\r\n		System.out.println(res);\r\n		System.out.println(-4.0/0); //-Infinity\r\n				\r\n		System.out.println(0.0/0);  //NaN\r\n	}\r\n}\r\n\r\n```\r\n\r\n常量表示\r\n\r\n```java\r\ndouble NEGATIVE_INIFINITY = Double.NEGATIVE_INFINITY;\r\ndouble POSITIVE_INIFINITY = Double.POSITIVE_INFINITY;\r\nfloat zInifinity = Float.POSITIVE_INFINITY;\r\nfloat fInifinity = Float.NEGATIVE_INFINITY;\r\n\r\n```\r\n\r\n那么 Double 家和 Float 家的无穷大在值上会相等吗?\r\n\r\n```java\r\nSystem.out.println(NEGATIVE_INIFINITY == fInifinity);	//答案: true\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n**下划线表示法**\r\n\r\nJava 中**无论小数还是整数**, 都可以用下划线分隔开而不影响数值本身.\r\n\r\n_Number.java\r\n\r\n```java\r\npackage chap3.zh;\r\n\r\n/**\r\n * @name  _Number\r\n * @layer chap3.zh\r\n * @intro	数值中可以穿插下划线分割, 以增强数字的可读性\r\n * @function\r\n * */\r\npublic class _Number {\r\n	public static void main(String[] args) {\r\n		double pi = 3.14_159_26;\r\n		System.out.println(pi); 	//3.1415926\r\n		int x = 0b100_0000__0000_0000_0000; //262144\r\n		System.out.println(x); 		//262144\r\n	}\r\n}	\r\n\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n整数&小数\r\n\r\n在整数相除的时候, 当无法整除的时, 得到整数部分的原因是因为只截取整数部分的数据.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 〖非数值类型〗\r\n\r\n唯一一个非数值型的基本数据类型\r\n\r\n值: true false\r\n\r\n```\r\n不存在 0 1 的值, 没有数值的值代替, 所以更不存在和其它基本数据类型互转的情况.\r\n但是像其它基本类型一样, 它也会和字符串类型的拼接互转.\r\n\r\n```\r\n\r\nStrBool.java\r\n\r\n```java\r\npackage chap3.str;\r\n\r\n/**\r\n * @name  StrBool\r\n * @layer chap3.str\r\n * @intro	布尔值遇到字符串拼接转字符串不是例外\r\n * @function\r\n * */\r\npublic class StrBool {\r\n	public static void main(String[] args) {\r\n		String s = true + \"\";\r\n		System.out.println(s); //true(字符串类型)\r\n		System.out.println(s + 123); //true123\r\n		System.out.println(s+1.2f);  //true1.2(不是 true1.2f, 说明字符串拼接转换是一种\"等值转换\")		\r\n	}\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n###### 布尔变量的作用\r\n\r\n```\r\n布尔变量在程序中一般是作为旗标使用的.\r\n常出现的结构有\r\nif()\r\nwhile()\r\ndo {} while ()\r\nfor () 的第二个参数\r\n三目运算 ?:\r\n运用场景: 条件查询&三目运算\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 专题: 为什么计算机需要补码来表示负数而不是用一个符号位就好了?\r\n\r\n补码\r\n\r\n```\r\n正数的补码等于原码\r\n负数的补码就是把正数全部取反然后+1\r\n\r\n```\r\n\r\n首先, 假设负数不用补码表示, 试着计算  $1+-2$ \r\n\r\n已知最高位为符号位, `0`+`1`-\r\n\r\n```\r\n1 	 0 0 0 0 1	忽略了中间的位数(以免数字过长)\r\n-2	 1 0 0 1 0  (只使用符号位表示负数)\r\n现在对二进制表示做加法\r\n	0 0 0 0 1\r\n+	1 0 0 1 0\r\n=	1 0 0 1 1	结果得到的却是 -3, 不是 -1\r\n\r\n```\r\n\r\n现在改用补码, 再一次试着计算\r\n\r\n```\r\n-2 的补码表示\r\n正数	0 0 0 1 0\r\n取反	1 1 1 0 1\r\n加一	1 1 1 1 0	(加一正好把取反后把数字往前推了一把 变得有那么点像 \"2\" 了)\r\n\r\n```\r\n\r\n现在对二进制表示做加法\r\n\r\n```\r\n	0 0 0 0 1\r\n+	1 1 1 1 0\r\n=	1 1 1 1 1	(而 1 的补码正是 11111)\r\n\r\n```\r\n\r\n现象表明的规律: 改成补码后, 计算机可以通过做加法得到正确答案.\r\n\r\n所以, 计算机才使用<mark>补码</mark>表示数字.\r\n\r\n> 所以, 人们一直说的\"计算机内部存放的是数字的二进制\"还不够准确和完善, 准确地说,\r\n>\r\n> 计算机里存放的都是数字的二进制补码.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '2021-04-26');
INSERT INTO `post` VALUES (42, 'Java', '运算符号', '', '## 运算符号\r\n\r\n\r\n\r\n四则\r\n\r\n\r\n\r\n### 位运算符\r\n\r\nMovR.java\r\n\r\n```java\r\npackage chap3.no7;\r\n\r\n/**\r\n * @name  MovR\r\n * @layer chap3.no7\r\n * @intro	>> 对内存中的位做运算\r\n * @function	位运算符\r\n * */\r\npublic class MovR {\r\n	public static void main(String[] args) {\r\n		System.out.println(8>>1);	//4		\r\n		System.out.println(8<<1);	//16\r\n	}\r\n}\r\n```\r\n\r\n#### Java 中支持的位运算符\r\n\r\n```\r\n<< >>	(移动型)\r\n&		(判断型)\r\n```\r\n\r\n\r\n\r\n& \r\n\r\n名字: 按位与\r\n\r\n理解: 与 (&), 与就是和, 和就是且. 1 且 1 为 1.\r\n\r\n运算: 同时为 1 则为 1.\r\n\r\n\r\n\r\n', '2021-04-26');
INSERT INTO `post` VALUES (43, 'Java', 'Java数组', '', '# Java数组\r\n\r\n\r\n\r\n#### 数组声明\r\n\r\n```java\r\nint[] a = new int[10];	\r\nint a[] = new int[10];\r\n```\r\n\r\n两种声明都可以, ① 会更加符合 Java 的变量声明习惯\r\n\r\n\r\n\r\n#### 数组初始化\r\n\r\n起因: 在写一个对有序数组线性查找的 demo, 初始化时被警告了 ↓\r\n\r\n```\r\nint[] tarArr = new int[5] {1, 3, 5, 70, 9};\r\n```\r\n\r\n##### 语法\r\n\r\n```java\r\nintp[] arr = new int[]{1, 3, 5, 70, 9};	//静态初始化\r\n```\r\n\r\n因为静态初始化是在 `{}` 中显性自行定义任意个元素, 所以不需要长度参数.\r\n\r\n\r\n\r\n#### Arrays 类\r\n\r\n常规数据不能一步到位的操作 Array 可以.\r\n\r\n##### 1.排序\r\n\r\n```java\r\nint[] a = {1, 3, 2, 4, 5};\r\nArrays.sort(a);	//	1,2,3,4,5\r\n```\r\n\r\n##### 2.展示\r\n\r\n```java\r\nint[] a = {1, 3, 2, 4, 5};\r\nSystem.out.println(Arrays.toString(aa));	//[1, 3, 2, 4, 5]\r\n```\r\n\r\n', '2021-04-26');
INSERT INTO `post` VALUES (44, 'Java', 'Java03-流程控制', '', '# Java03-流程控制\r\n\r\n[TOC]\r\n\r\n### 导入\r\n\r\n#### coutinue\r\n\r\nbreak: \"到此为止\"\r\n\r\ncoutinue: \"只是过滤当前轮后半部分的程序, 后面的循环还是会进行\"\r\n\r\nContinueTest.java\r\n\r\n```java\r\npackage chap4.no4;\r\n\r\n/**\r\n * @name  ContinueTest\r\n * @layer chap4.no4\r\n * @role	continue 的作用\r\n * @able	continue 仅仅是过滤掉当前轮后半部分的语句\r\n * */\r\npublic class ContinueTest {\r\n	public static void main(String[] args) {\r\n		for (int i = 0; i < 3; i++) {\r\n			System.out.println(i);\r\n			if (i == 1) {\r\n				continue;\r\n			}\r\n			System.out.println(\"coutinue 后的语句\");\r\n		}\r\n	}\r\n	//0\r\n	//coutinue 后的语句\r\n	//1\r\n	//2\r\n	//coutinue 后的语句\r\n\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n### switch-case\r\n\r\n##### 可接受的参数类型\r\n\r\n5 种整数类型, 字符串, 枚举, 不接受布尔类型/浮点数\r\n\r\n```\r\nchar\r\nbyte short\r\nint	 long \r\n```\r\n\r\n\r\n\r\n\r\n\r\n##### 为什么 `switch-case` 总是要搭配 `break` 使用\r\n\r\n因为 switch-case 匹配后是瀑布式地执行, 直到遇到下一个 `break` 才会结束.\r\n\r\n###### 演示1-1: /chap4/src/chap4/no4/SwitchBreak.java\r\n\r\n```java\r\npackage chap4.no4;\r\n\r\n/**\r\n * @name  SwitchBreak\r\n * @layer chap4.no4\r\n * @intro	演示 break 在 switch-case 中的作用 \r\n * @function 说明了 switch-case 不总是匹配执行, 而是要搭配 break 刹车\r\n * */\r\npublic class SwitchBreak {\r\n	\r\n	public static void main(String[] args) {\r\n		int n = 10;\r\n		System.out.println(\"n = \" + n);\r\n		\r\n		switch(n) {\r\n		case 10:\r\n		{\r\n			System.out.println(\"匹配到 10 时: \" + n);\r\n		}\r\n		case 11:\r\n		{\r\n			n++;\r\n			System.out.println(\"匹配到 11 时: \" + n);\r\n		}\r\n		default:\r\n		}\r\n		//n = 10\r\n		//匹配到 10 时: 10\r\n		//匹配到 11 时: 11\r\n	}\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n#### try-catch-finally\r\n\r\n`return` 不总是方法的结束点.\r\n\r\n```java\r\npackage com.jt.practice.control;\r\n\r\n/**\r\n * 牛客每日练习\r\n * @author Jonty Zheng\r\n */\r\n\r\npublic class FinallyTest {\r\n    public static void main(String[] args) {\r\n        int num = 10;\r\n        int x = test(num);\r\n        System.out.println(x);\r\n    }\r\n\r\n    public static int test(int b) {\r\n        try {\r\n            b += 10;\r\n            return b;\r\n            //如果输出 20 说明只执行到这里结束\r\n        } catch (RuntimeException e) {\r\n\r\n        } catch (Exception e2) {\r\n\r\n        } finally {\r\n            b += 10;\r\n            return b;\r\n            //如果输出 30 说明执行到这里结束\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n输出\r\n\r\n```\r\nD:\\Java\\jdk1.8.0_102\\bin\\java.exe \"-javaagent:D:\\Program Files\\JetBrains\\IntelliJ IDEA 2019.3.1\\lib\\idea_rt.jar=4106:D:\\Program Files\\JetBrains\\IntelliJ IDEA 2019.3.1\\bin\" -Dfile.encoding=UTF-8 -classpath D:\\Java\\jdk1.8.0_102\\jre\\lib\\charsets.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\deploy.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\ext\\access-bridge-64.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\ext\\cldrdata.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\ext\\dnsns.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\ext\\jaccess.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\ext\\jfxrt.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\ext\\localedata.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\ext\\nashorn.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\ext\\servlet-api.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\ext\\sunec.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\ext\\sunjce_provider.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\ext\\sunmscapi.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\ext\\sunpkcs11.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\ext\\zipfs.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\javaws.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\jce.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\jfr.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\jfxswt.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\jsse.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\management-agent.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\plugin.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\resources.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\rt.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\servlet-api.jar;E:\\code\\se-idea\\out\\production\\se-workspace;D:\\repository\\junit\\junit\\4.12\\junit-4.12.jar;D:\\repository\\org\\hamcrest\\hamcrest-core\\1.3\\hamcrest-core-1.3.jar com.jt.practice.control.FinallyTest\r\n30\r\n```\r\n\r\n', '2021-04-26');
INSERT INTO `post` VALUES (45, 'Java', 'Java03-流程控制', '', '# Java03-流程控制\r\n\r\n[TOC]\r\n\r\n### 导入\r\n\r\n#### coutinue\r\n\r\nbreak: \"到此为止\"\r\n\r\ncoutinue: \"只是过滤当前轮后半部分的程序, 后面的循环还是会进行\"\r\n\r\nContinueTest.java\r\n\r\n```java\r\npackage chap4.no4;\r\n\r\n/**\r\n * @name  ContinueTest\r\n * @layer chap4.no4\r\n * @role	continue 的作用\r\n * @able	continue 仅仅是过滤掉当前轮后半部分的语句\r\n * */\r\npublic class ContinueTest {\r\n	public static void main(String[] args) {\r\n		for (int i = 0; i < 3; i++) {\r\n			System.out.println(i);\r\n			if (i == 1) {\r\n				continue;\r\n			}\r\n			System.out.println(\"coutinue 后的语句\");\r\n		}\r\n	}\r\n	//0\r\n	//coutinue 后的语句\r\n	//1\r\n	//2\r\n	//coutinue 后的语句\r\n\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n### switch-case\r\n\r\n##### 可接受的参数类型\r\n\r\n5 种整数类型, 字符串, 枚举, 不接受布尔类型/浮点数\r\n\r\n```\r\nchar\r\nbyte short\r\nint	 long \r\n```\r\n\r\n\r\n\r\n\r\n\r\n##### 为什么 `switch-case` 总是要搭配 `break` 使用\r\n\r\n因为 switch-case 匹配后是瀑布式地执行, 直到遇到下一个 `break` 才会结束.\r\n\r\n###### 演示1-1: /chap4/src/chap4/no4/SwitchBreak.java\r\n\r\n```java\r\npackage chap4.no4;\r\n\r\n/**\r\n * @name  SwitchBreak\r\n * @layer chap4.no4\r\n * @intro	演示 break 在 switch-case 中的作用 \r\n * @function 说明了 switch-case 不总是匹配执行, 而是要搭配 break 刹车\r\n * */\r\npublic class SwitchBreak {\r\n	\r\n	public static void main(String[] args) {\r\n		int n = 10;\r\n		System.out.println(\"n = \" + n);\r\n		\r\n		switch(n) {\r\n		case 10:\r\n		{\r\n			System.out.println(\"匹配到 10 时: \" + n);\r\n		}\r\n		case 11:\r\n		{\r\n			n++;\r\n			System.out.println(\"匹配到 11 时: \" + n);\r\n		}\r\n		default:\r\n		}\r\n		//n = 10\r\n		//匹配到 10 时: 10\r\n		//匹配到 11 时: 11\r\n	}\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n#### try-catch-finally\r\n\r\n`return` 不总是方法的结束点.\r\n\r\n```java\r\npackage com.jt.practice.control;\r\n\r\n/**\r\n * 牛客每日练习\r\n * @author Jonty Zheng\r\n */\r\n\r\npublic class FinallyTest {\r\n    public static void main(String[] args) {\r\n        int num = 10;\r\n        int x = test(num);\r\n        System.out.println(x);\r\n    }\r\n\r\n    public static int test(int b) {\r\n        try {\r\n            b += 10;\r\n            return b;\r\n            //如果输出 20 说明只执行到这里结束\r\n        } catch (RuntimeException e) {\r\n\r\n        } catch (Exception e2) {\r\n\r\n        } finally {\r\n            b += 10;\r\n            return b;\r\n            //如果输出 30 说明执行到这里结束\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n输出\r\n\r\n```\r\nD:\\Java\\jdk1.8.0_102\\bin\\java.exe \"-javaagent:D:\\Program Files\\JetBrains\\IntelliJ IDEA 2019.3.1\\lib\\idea_rt.jar=4106:D:\\Program Files\\JetBrains\\IntelliJ IDEA 2019.3.1\\bin\" -Dfile.encoding=UTF-8 -classpath D:\\Java\\jdk1.8.0_102\\jre\\lib\\charsets.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\deploy.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\ext\\access-bridge-64.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\ext\\cldrdata.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\ext\\dnsns.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\ext\\jaccess.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\ext\\jfxrt.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\ext\\localedata.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\ext\\nashorn.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\ext\\servlet-api.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\ext\\sunec.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\ext\\sunjce_provider.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\ext\\sunmscapi.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\ext\\sunpkcs11.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\ext\\zipfs.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\javaws.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\jce.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\jfr.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\jfxswt.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\jsse.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\management-agent.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\plugin.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\resources.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\rt.jar;D:\\Java\\jdk1.8.0_102\\jre\\lib\\servlet-api.jar;E:\\code\\se-idea\\out\\production\\se-workspace;D:\\repository\\junit\\junit\\4.12\\junit-4.12.jar;D:\\repository\\org\\hamcrest\\hamcrest-core\\1.3\\hamcrest-core-1.3.jar com.jt.practice.control.FinallyTest\r\n30\r\n```\r\n\r\n', '2021-04-26');
INSERT INTO `post` VALUES (46, 'Java', 'Java03-字符串', '', '# Java03-字符串\r\n\r\n[TOC]\r\n\r\n##### 字符串反转\r\n\r\n```java\r\n    String s = \"abcdefg\";\r\n    System.out.println(new StringBuffer(s).reverse().toString()); //gfedcba\r\n```\r\n\r\n应用: 值为升序数字串现在要转化成倒序数字串\r\n\r\n\r\n\r\n\r\n\r\n##### char & String\r\n\r\n判断字符串中是否含有某个字符, 如果有的话获取其所在的索引\r\n\r\n> api: int indexOf(String str) ：返回第一次出现的指定子字符串在此字符串中的索引位置。 \r\n\r\n```java\r\npackage chao3.no8;\r\n\r\n/**\r\n * @name  StrGotChar\r\n * @layer chao3.no8\r\n * @intro	返回字符在字符串中的位置, 顺便判断是否包含该字符\r\n * @function\r\n * */\r\npublic class StrGotChar {\r\n	public static void main(String[] args) {\r\n		//一个字符串\r\n		String mom = \"abcdee\";\r\n		char c = \'e\';						//参数传入 c\r\n		System.out.println(mom.indexOf(c));	//4\r\n	}\r\n}\r\n```\r\n\r\n\r\n\r\n##### int & String\r\n\r\n数值型的字符串, 获取其中的字面值, 用 `Integer`的提取术 valueOf\r\n\r\n```java\r\npackage chap3.str;\r\n\r\n/**\r\n * @name  StringToInt\r\n * @layer chap3.no5\r\n * @intro	输出数字型字符串里的字面值\r\n * @function	介绍方法\r\n * */\r\npublic class StringToInt {\r\n	\r\n	public static void main(String[] args) {\r\n		String a = \"1234\";\r\n		int aVal = Integer.valueOf(a);	//1234\r\n		System.out.println(aVal); 		//1234		\r\n	}	\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n##### String & int\r\n\r\n数字转字符串 2 种方法\r\n\r\n1.字符串拼接\r\n\r\n2.`String` 的提取术 valueOf\r\n\r\n```java\r\nstrArr[i] = String.valueOf(nums[i]);\r\nstrArr[i] = nums[i] + \"\";\r\n```\r\n\r\n\r\n\r\n\r\n\r\n```\r\n后者更快, 同一个算法, 只修改该部分的实现, 前者执行 13 ms, 后者执行 6ms (参考 leetcode179)\r\n```\r\n\r\n\r\n\r\n##### compareTo\r\n\r\n两个字符串之间 compareTo, 返回开头字符 ASCII 码值相减的差值.\r\n\r\n```java\r\npackage chap3.str;\r\n\r\n/**\r\n * @name  CompareTo\r\n * @layer chap3.str\r\n * @intro	compareTo():int 开头的字符相见的差值\r\n * @function\r\n * */\r\npublic class CompareTo {\r\n	public static void main(String[] args) {\r\n		String s1 = \"abc\";\r\n		String s2 = \"bcd\";\r\n		System.out.println(s1.compareTo(s2));	//-1\r\n		String s3 = \"g\";\r\n        //dbdefg\r\n		System.out.println(s2.compareTo(s3));   //-5\r\n	}\r\n}\r\n```\r\n\r\n\r\n\r\n##### 常量在常量池里的复用\r\n\r\n字符串常量在常量池中缓存, 当遇到相同的值时, 复用池里的变量.\r\n\r\n```java\r\npackage chap3.str;\r\n\r\n/**\r\n * @name  ChangLiang\r\n * @layer chap3.str\r\n * @intro	字符串常量\r\n * @function	字符串常量用常量缓存, 如果字符串常量值重复(常量拼接也算), 则复用上一个常量\r\n * */\r\npublic class ChangLiang {\r\n	public static void main(String[] args) {\r\n		String s1 = \"hello\";\r\n		String s2 = \"he\" + \"llo\";	//多个常量拼接还是常量\r\n		String s3 = \"hello\";\r\n		\r\n		//查看以上 \"3\" 个变量的内存地址 \r\n		System.out.println(s1==s2);\r\n		System.out.println(s1==s3);\r\n		//输出\r\n		//true\r\n		//true\r\n		\r\n		String s4 = \"he\";\r\n		String s5 = \"llo\";				\r\n		String s6 = s4+s5;\r\n		System.out.println(s6);\r\n		\r\n		System.out.println(s1 == s6);\r\n		//输出\r\n		//false				\r\n	}\r\n}\r\n```\r\n\r\n内存\r\n\r\nJava 会确保每个字符串常量只有一个, 不会产生多个副本, 当有同一个值的字符串被引用时, 优先使用常量池内已有的变量, 不另外开辟空间.\r\n\r\n疯狂 Java 讲义 3.6.2. 直接量的赋值 | 提示', '2021-04-26');
INSERT INTO `post` VALUES (47, 'Java', 'Java-3-常用运算', '', '# Java-3-常用运算\r\n\r\n\r\n\r\n绝对值\r\n\r\n`Math.abs()`\r\n\r\n```java\r\npackage chap3.calc;\r\n\r\n/**\r\n * @name  MathAbd\r\n * @layer chap3.calc\r\n * @intro	求绝对值\r\n * @function\r\n * */\r\npublic class MathAbs {\r\n	public static void main(String[] args) {\r\n		System.out.println(Math.abs(-2));	//2\r\n		System.out.println(Math.abs(12-30));	//18\r\n	}\r\n}	\r\n```\r\n\r\n应用: 求差值\r\n\r\n\r\n\r\n随机数\r\n\r\n`Math.random()`\r\n\r\n生成 0-1 之间的随机小数. \r\n\r\n随机数和随机数的变形\r\n\r\n```java\r\n//生成 0~1 之间的随机数\r\nSystem.out.println(Math.random()); 			//0.45739820511766016\r\n//生成 1~10 之间的随机数\r\nSystem.out.println(Math.random()*10); 		//7.014110425875772\r\nSystem.out.println((int) (Math.random()*10 + 98));	//104\r\nSystem.out.println((int) (Math.random()*10 + 65));	//68\r\nSystem.out.println((char)(int) (Math.random()*10 + 98));	//j	\r\nSystem.out.println((char)(int)(Math.random()+65));	//A\r\n```\r\n\r\n\r\n\r\n\r\n\r\nn 次方运算\r\n\r\n`Math.pow(a, b)`\r\n\r\n返回类型是 `double`\r\n\r\n```java\r\nSystem.out.println(Math.pow(1, 3) + Math.pow(5, 3) + Math.pow(3, 3));	//153.0\r\n```\r\n\r\n', '2021-04-26');
INSERT INTO `post` VALUES (48, 'Java', 'Java05-Java核心', '', '# Java05-Java核心\r\n\r\n[TOC]\r\n\r\n#### *public 方法才能跨包访问\r\n\r\n事情是这样的: \r\n\r\n```\r\n我在 `service` 中写了 调用 `dao` 中的添加用户方法 `addMan(String name)`\r\n但是在 `controller` 中调用 `service` 执行该方法的地方, 提示 `Cannot be accessed from outside package`\r\n提示 \'make method in service public\'\r\n```\r\n\r\n这是原 `service` 中的 `add ` 方法\r\n\r\n```java\r\n@Service\r\npublic class ManService {\r\n\r\n    @Autowired\r\n    ManMapper manMapper;\r\n\r\n    //public\r\n    void addMan(String name) {\r\n        manMapper.addMan(name);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 类内重载\r\n\r\n例子: `a+b` 可以有的的重载形式\r\n\r\n```java\r\npublic 构造器(..){}\r\npublic int sum(int a, int b);\r\npublic int sum(int a, int b, int c);\r\npublic double sum(double a, double b);\r\npublic double sum(double a, double a, double);\r\n```\r\n\r\n访问的时候既可以调用计算 2 个整数的加法, 还可以是 3 个整数的加法. \r\n\r\n不仅如此, 还可以计算 2 甚至 3 个整数的加法. \r\n\r\n外界看上去好像一个方法名可以用在不同参数, 不同类型的参数运算(处理)一样.\r\n\r\n原则: 同名不同参.\r\n\r\n无关因素: 返回值类型是无关的, 方法修饰符是无关的.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 跨类重写\r\n\r\n重写, 又叫覆盖.\r\n\r\n通过继承父类, 写出子类定制化的方法.\r\n\r\n```java\r\nclass Papa {\r\n    public void say() {\r\n        System.out.println(\"我会跑\");\r\n    }\r\n}\r\n```\r\n\r\n```java\r\nclass OffSpring extends Papa{\r\n    @Override\r\n    public void say() {\r\n		System.out.println(\"我会飞\");\r\n    }\r\n}\r\n```\r\n\r\n说明\r\n\r\n```\r\n从继承的角度来说, 子类默认继承拥有父类的方法. 子类的类体可以为空, 对象又可以调用出父类里已有的方法.\r\n从丰富性来说, 子类可以写别的方法, 在子类中写父类里没有声明的方法, 从而构造一个更加丰富的类.\r\n不仅如此, 子类还可以重写父类的方法, 定制化自己的方法, 这也是一种增强丰富度的方式(可以多写, 可以写自己的)\r\n前提是, 仅限于相同的方法原型. 也就是子类**可以写别的方法, 不能和原父类方法重名**.\r\n重写的前提是**复制父类的方法原型, 修改方法体.\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 抽象类——特殊的父类\r\n\r\n它, 可以有**不实现方法体**的方法, 可以像父类一样有属性, 有方法, 也都能像平常父类一样被继承. 但唯一的缺陷是, 它不能实例化, 也就是, 不能拥有自己的对象.\r\n\r\n它的对象必须由实现的非抽象类构造.\r\n\r\n```\r\nAbstraPapa man = new Son();\r\n```\r\n\r\n2021-04-07 \r\n\r\n方法体\r\n\r\n```java\r\n{\r\n	//...\r\n}\r\n```\r\n\r\n抽象方法\r\n\r\n```java\r\npublic abstract void go();\r\n//没有方法体的方法叫做抽象方法\r\n\r\n```\r\n\r\n抽象类&抽象方法\r\n\r\n```\r\n普通类声明一个方法要不 add body 要么提醒声明 add abstract\r\n\r\n说明, 正常类如果声明方法一定要有方法体.\r\n没有方法体的类被动声明称抽象类.(只有抽象类才能拥有抽象方法, 正常类该有的还是要有)\r\n\r\n```\r\n\r\n\r\n\r\n抽象类&接口的相同点\r\n\r\n1.都不能自己创建实例: 抽象类要依赖非抽象的子类, 接口要依赖实现类.\r\n\r\n\r\n\r\n\r\n\r\n#### 其它\r\n\r\n```\r\njava没有指针机制——牛客\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### 接口\r\n\r\n> Cannot reduce the visibility of the inherited method from Interface\r\n\r\n假如接口中的方法可见性是 `public` , 实现只能扩展不能降低可见性.\r\n\r\n如\r\n\r\n```\r\n接口方法 f() 是 int f();\r\n实现类中 f() 不能是 int f();\r\n但可以是 public int f();\r\n\r\n```\r\n\r\n已上机验证.\r\n\r\n\r\n\r\n[牛客](https://m.nowcoder.com/questions?uuid=a7079fcaacef419c9bcbf2bf407cb3da)', '2021-04-26');
INSERT INTO `post` VALUES (49, 'Java', '构造器', '', '## 构造器\r\n\r\n[TOC]\r\n\r\n例子:  Dog & DogTest\r\n\r\n```java\r\npublic class Dog {	\r\n	int eyeNum;\r\n	\r\n	Dog(int n) {\r\n		eyeNum = n;\r\n		System.out.println(\"构造器初始化\");\r\n	}\r\n	\r\n	public void run() {\r\n		System.out.println(\"开始跑\");\r\n	}\r\n}\r\n```\r\n\r\n```java\r\npublic class DogTest {\r\n	public static void main(String[] args) {\r\n		Dog dog = new Dog(2);\r\n		dog.run();\r\n		//构造器初始化\r\n		//开始跑\r\n	}\r\n}\r\n```\r\n\r\n\r\n\r\n构造器\r\n\r\n构造器是和类同名的特殊方法, 看上去没有返回值(写法上, 实际上会返回一个对象, 这也是另一个和普通方法不一样的地方).\r\n\r\n通常用于构造类对象, 用 `new` 调用.\r\n\r\n\r\n\r\n构造器重载\r\n\r\n每个类都有一个默认的无参构造器, 用于创建对象.\r\n\r\n一经重载, 便被覆盖.\r\n\r\n\r\n\r\n```\r\n如果多个重载的构造器里包含了相同的初始化代码, 可以将这些初始化代码放置到普通的初始化块里完成\r\n初始化块总是构造器执行之前被调用\r\n```\r\n\r\n\r\n\r\n\r\n\r\n##### 比构造器提前执行的代码块\r\n\r\n普通初始化块\r\n\r\n```\r\n{\r\n	System.out.println(\"执行..\");\r\n}\r\n```\r\n\r\n普通代码块的执行在对象加载之后, 构造器执行之前被调用. 如:\r\n\r\n```java\r\npublic class CodeBlock {			\r\n	\r\n	{		\r\n		System.out.println(\"代码块内里的执行语句\");\r\n	}\r\n	\r\n	//构造器\r\n	CodeBlock() {\r\n		System.out.println(\"构造器里的执行语句\");\r\n	}\r\n}\r\n```\r\n\r\n```java\r\npublic class CodeBlockUse {\r\n	public static void main(String[] args) {\r\n		CodeBlock cb = new CodeBlock();\r\n       //输出\r\n		//代码块内里的执行语句\r\n		//构造器里的执行语句\r\n	}\r\n}	\r\n```\r\n\r\n猜想: 构造器通常是用作成员初始化的, 既然普通代码块执行在构造器之前, 那为什么不用它先把初始化成员呢?\r\n\r\n验证: 在 `CodeBlock` 中增加 `n` 成员, 并在普通代码块里初始化.\r\n\r\n```java\r\npublic class CodeBlock {\r\n	\r\n	//假设 CodeBlock 有一个属性 n 等待初始化\r\n	int n;	\r\n	\r\n	{\r\n		n = 2;				\r\n		System.out.println(\"代码块内里的执行语句\");\r\n	}\r\n	\r\n	//构造器\r\n	CodeBlock() {\r\n		System.out.println(\"构造器里的执行语句\");\r\n	}\r\n}\r\n```\r\n\r\n```java\r\npublic class CodeBlockUse {\r\n	public static void main(String[] args) {\r\n		CodeBlock cb = new CodeBlock();\r\n		//输出\r\n		//代码块内里的执行语句\r\n		//构造器里的执行语句\r\n		System.out.println(\"cd对象的n为: \" + cb.n);	\r\n        //输出\r\n        //cd对象的n为: 2\r\n	}\r\n}	\r\n```\r\n\r\n初始化块&初始化块的应用', '2021-04-26');
INSERT INTO `post` VALUES (50, 'Java', 'Java08-Java集合', '', '# Java08-Java集合\r\n\r\n\r\n\r\nList\r\n\r\nlist 转 int[] 的冷门方法:\r\n\r\n```java\r\n    List<Integer> list = new ArrayList<>();\r\n    list.add(10);\r\n    list.add(11);\r\n    int[] a = list.stream().mapToInt(Integer::intValue).toArray(); 	//[10, 11]\r\n```\r\n\r\n应用: 有时候用 List 操作得到一定长度的整数的时候, 方法的返回值类型要是 int[] 类型.\r\n\r\n', '2021-04-26');
INSERT INTO `post` VALUES (51, 'Java', 'Java18-代理', '', '## Java18-代理\r\n\r\n[TOC]\r\n\r\n#### 铺垫\r\n\r\n```\r\n我们知道, 接口是不能自己创建实例的. 要想使用接口正常都会通过接口的实现类对象实现的.\r\n可是, 有一种可能, 不编写实现类, 也能让接口运行起来\r\nJava提供了这么一套动态代理机制.\r\n```\r\n\r\n#### 案例\r\n\r\n定义静态接口\r\n\r\n```java\r\npublic interface Hello {\r\n    void morning(String name);\r\n}\r\n```\r\n\r\n定义一个 <font color=\"green\">`InvocationHandler` </font>的实现类\r\n\r\n实现类中实现 <font color=\"green\">`invoke`</font> 方法, 用它创建的代理对象的接口方法都会被如下的方法给替换掉.\r\n\r\n```java\r\npublic class HelloInvocationHandler implements InvocationHandler {\r\n\r\n    private Hello hello;\r\n\r\n    @Override\r\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n        System.out.println(method);\r\n        //接口中如果有多个方法, 只匹配名叫morning的方法, 匹配后打印morning\r\n        if (method.getName().equals(\"morning\")) {\r\n            System.out.println(\"morning\");\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n代理\r\n\r\n```java\r\npublic class HelloProxyUse {\r\n    public static void main(String[] args) {\r\n        InvocationHandler handler = new HelloInvocationHandler();\r\n        Hello h = (Hello) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class[]{Hello.class}, handler);\r\n        h.morning(\"你好\");\r\n        //输出\"morning\"\r\n    }\r\n}\r\n```\r\n\r\n此时, `Hello` 的 `morning()` 方法已经不是 `Hello` 的 `morning()`  了. 否则是打印 **\"你好\"** 的.\r\n\r\n\r\n\r\n参考\r\n\r\n[动态代理 - 廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/1252599548343744/1264804593397984)\r\n\r\n##### 应用\r\n\r\n已知, 重写 `invoke()` 我们可以替换掉原来对象的方法, 既然可以定制化, 那么我们也可以选择保留,  然后往前后端执行不同的方法, 达到\"代码片段插入\"的效果.\r\n\r\n例: 代理 `Dog` 的对象, 然后在原方法前后添加不同的方法, 这些方法将放到一个专门的类里管理——切面类.\r\n\r\n原接口\r\n\r\n```java\r\npackage spring.no;\r\n\r\npublic interface UserDao {\r\n\r\n    public void addUser();\r\n    public void deleteUser();\r\n}\r\n```\r\n\r\n接口实现类\r\n\r\n这里做了一个小的修改, 我们需要接口实现类自己能调用方法. 夹在 `invoke()` 中间.\r\n\r\n```java\r\npackage spring.no;\r\n\r\n//提示: 目标类\r\npublic class UserDaoImpl implements UserDao {\r\n    @Override\r\n    public void addUser() {\r\n        System.out.println(\"添加一个用户\");\r\n    }\r\n\r\n    @Override\r\n    public void deleteUser() {\r\n        System.out.println(\"减少一个用户\");\r\n    }\r\n}\r\n```\r\n\r\n管理类\r\n\r\n代理中将声明这个类的对象, 并在前后执行\r\n\r\n```java\r\npackage spring.no.aspect;\r\n\r\n//切面\r\npublic class MyAspect {\r\n\r\n    //模拟权限检查\r\n    public void check_permission() {\r\n        System.out.println(\"from MyAspect: 模拟权限检查\");\r\n    }\r\n\r\n    //模拟日志记录\r\n    public void log() {\r\n        System.out.println(\"from MyAspect: 模拟日志记录\");\r\n    }\r\n}\r\n\r\n```\r\n\r\n代理\r\n\r\n将代理对象从主类那边抽了过来, 单独封装成一个方法 `createProxy` \r\n\r\n调用原类的方法: `method.invoke(对象, args)` | 传递对象和对象所需(所有)的方法参数\r\n\r\n```java\r\npackage spring.no.proxy;\r\n\r\nimport spring.no.UserDao;\r\nimport spring.no.aspect.MyAspect;\r\n\r\nimport java.lang.reflect.InvocationHandler;\r\nimport java.lang.reflect.Method;\r\nimport java.lang.reflect.Proxy;\r\n\r\n\r\npublic class JdkProxy implements InvocationHandler {\r\n    UserDao userDao;\r\n\r\n    @Override\r\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n        MyAspect msp = new MyAspect();\r\n        msp.check_permission();\r\n        //调用类原本的方法\r\n        method.invoke(userDao, args);\r\n        //\r\n        msp.log();\r\n        return null;\r\n    }\r\n\r\n    public Object createProxy(UserDao userDao) {\r\n        this.userDao = userDao;\r\n        return Proxy.newProxyInstance(this.userDao.getClass().getClassLoader(), new Class[]{UserDao.class}, this);\r\n    }\r\n}\r\n\r\n```\r\n\r\n测试\r\n\r\n```java\r\npackage spring.no;\r\n\r\nimport spring.no.proxy.JdkProxy;\r\n\r\npublic class ProxyUse {\r\n    public static void main(String[] args) {\r\n        //1.代理对象\r\n        JdkProxy proxy = new JdkProxy();\r\n        //(等待对象传入创建代理类)\r\n        //2.目标出现\r\n        UserDao userDao = new UserDaoImpl();\r\n        //3.代理\r\n        UserDao userDao1 = (UserDao)proxy.createProxy(userDao);\r\n        //(经过 invoke() 方法后的方法执行)\r\n        //执行测试, 查看是否有切入切面类的方法\r\n        userDao1.addUser();\r\n        //由于 invoke() 经过了定制化, 所以输出会出现夹心饼干的行\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n2021-04-07 22:36:15', '2021-04-26');
INSERT INTO `post` VALUES (52, 'Python', 'part02-Hello World!', '', '# part02-Hello World!\r\n\r\n[TOC]\r\n\r\n> 使用flask环境\r\n\r\n### 一.编写程序hello.py\r\n\r\n##### 文件1-1.D:\\code\\PycharmProjects\\hellp.py\r\n\r\n```python\r\nfrom flask import Flask		#从flask导入flask类\r\napp = Flask(__name__)		#传入一个参数创建一个实例 __name__表示模块\r\n\r\n@app.route(\'/\')	\r\ndef hello():\r\n    return \'Hello World!\'\r\n\r\nif __name__ == \'__main__\':\r\n    app.run(debug=True)				# 条件运行\r\n```\r\n\r\n### 二.运行程序\r\n\r\n```\r\n(venv) D:\\code\\PycharmProjects>python hello.py\r\nTraceback (most recent call last):\r\n  File \"hello.py\", line 1, in <module>\r\n    from flask import Flask\r\nModuleNotFoundError: No module named \'flask\'\r\n\r\n(venv) D:\\code\\PycharmProjects>python hello.py\r\n * Serving Flask app \"hello\" (lazy loading)\r\n * Environment: production\r\n   WARNING: This is a development server. Do not use it in a production deployment.\r\n   Use a production WSGI server instead.\r\n * Debug mode: off\r\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\r\n    \r\n```\r\n\r\n### 三.访问web\r\n\r\n```\r\n地址栏输入 http://127.0.0.1:5000/\r\n	画面中显示 Hello World!\r\n	\r\n原终端会多出两行显示连接信息:\r\n127.0.0.1 - - [09/Feb/2021 21:45:57] \"[37mGET / HTTP/1.1[0m\" 200 -\r\n127.0.0.1 - - [09/Feb/2021 21:45:57] \"[33mGET /favicon.ico HTTP/1.1[0m\" 404 -	\r\n```\r\n\r\n', '2021-04-26');
INSERT INTO `post` VALUES (53, 'Java', 'part03-熟悉', '', '# part03-熟悉\r\n\r\n[TOC]\r\n\r\n### 仿写hello flask\r\n\r\n#### 一.程序\r\n\r\n##### 文件1-1:(hello.py)\r\n\r\n```python\r\nfrom flask import Flask		#导入flask模块\r\napp = Flask(__name__)		#创建实例, 传入参数\r\n\r\n@app.route(\'/\')				#定义拦截请求\r\ndef hello():				#定义响应方法\r\n    return \'Hello World!\'\r\n\r\nif __name__ == \'__main__\':	#设置编译时运行(默认情况是导入时运行)\r\n    app.run()\r\n```\r\n\r\n> 运动后访问localhost:5000响应Hello World!\r\n\r\n##### 文件1-2:(仿写)saySleep.py(《眠》是最近在看的pdf)\r\n\r\n```python\r\nfrom flask import Flask		#键入flask会自动转为Flask\r\napp = Flask(__name__)		#name参数名不可改(预定义)\r\n\r\n@app.route(\"/saysomething\")\r\ndef say():\r\n    return \"say 《眠》\"\r\n\r\nif __name__ == \'__main__\'\r\n	app.run()\r\n```\r\n\r\n#### 二.运行访问\r\n\r\n在当前目录打开控制台, 编译运行\r\n\r\n```\r\n输入python saySleep.py\r\n	控制台显示以下内容\r\n		->	访问localhost:5000\r\n			->响应内容:	hello 《眠》\r\n```\r\n\r\n\r\n\r\n控制台\r\n\r\n```\r\nD:\\code\\PycharmProjects>python saySleep.py\r\n * Serving Flask app \"__name__\" (lazy loading)\r\n * Environment: production\r\n   WARNING: This is a development server. Do not use it in a production deployment.\r\n   Use a production WSGI server instead.\r\n * Debug mode: off\r\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\r\n```\r\n\r\n\r\n\r\n\r\n\r\n#### 三.路由\r\n\r\n类似controller的flask\r\n\r\napp.route可以像requestmapping一样绑定多个URL请求拦截, 像controller一样, 它也可以有多个app.route()\r\n\r\n###### 文件3-1:D:\\code\\PycharmProjects\\hellov2.py\r\n\r\n```python\r\nfrom flask import Flask\r\napp = Flask(__name__)\r\n\r\n@app.route(\'/\')\r\ndef hello():\r\n    return \'Hello Wor!\'\r\n\r\n@app.route(\'/index\')    \r\ndef index():\r\n    return \'index\'\r\n\r\nif __name__ == \'__main__\':\r\n    app.run(debug=True)\r\n```\r\n\r\n响应\r\n\r\n```\r\n访问localhost:5000\r\n	网页响应Hello Wor!\r\n访问localhost:5000/index		\r\n	网页响应index\r\n```\r\n\r\n\r\n\r\n#### 四.变量规则\r\n\r\n在URLt增加变量的部分\r\n\r\n比如: 在URL后增加参数的部分, 请求对应用户名的资料\r\n\r\n```python\r\nimport flask from Flask\r\napp = Flask(__name__)\r\n\r\n@app.route(\'/user/<username>\')\r\ndef show_user_profile(username):	#显示用户档案\r\n    return \'User %s\' % username	\r\n\r\n@app.route(\'/post/<int:post_id>\')	\r\ndef show_post(post_id):				#显示上传者id\r\n    return \'Post %d\' % post_id\r\n\r\nif __name==\'__main__\':\r\n    app.run()\r\n```\r\n\r\n转换器: `converter:var_name` \r\n\r\n表示URL中可接收的参数类型: int:post_id 表只接受整数类型的post_id\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 答疑\r\n\r\n##### 文档中说的\"这样, 就构成了我们第一个 WSGI程序\"\r\n\r\n其中的WSGI释义:服务器网关接口\r\n\r\n\r\n\r\n##### 打开debug模式有一个好处是\r\n\r\n可以让命令行也看见报错的日志.', '2021-04-26');
INSERT INTO `post` VALUES (54, 'Python', 'part03-熟悉', '', '# part03-熟悉\r\n\r\n[TOC]\r\n\r\n### 仿写hello flask\r\n\r\n#### 一.程序\r\n\r\n##### 文件1-1:(hello.py)\r\n\r\n```python\r\nfrom flask import Flask		#导入flask模块\r\napp = Flask(__name__)		#创建实例, 传入参数\r\n\r\n@app.route(\'/\')				#定义拦截请求\r\ndef hello():				#定义响应方法\r\n    return \'Hello World!\'\r\n\r\nif __name__ == \'__main__\':	#设置编译时运行(默认情况是导入时运行)\r\n    app.run()\r\n```\r\n\r\n> 运动后访问localhost:5000响应Hello World!\r\n\r\n##### 文件1-2:(仿写)saySleep.py(《眠》是最近在看的pdf)\r\n\r\n```python\r\nfrom flask import Flask		#键入flask会自动转为Flask\r\napp = Flask(__name__)		#name参数名不可改(预定义)\r\n\r\n@app.route(\"/saysomething\")\r\ndef say():\r\n    return \"say 《眠》\"\r\n\r\nif __name__ == \'__main__\'\r\n	app.run()\r\n```\r\n\r\n#### 二.运行访问\r\n\r\n在当前目录打开控制台, 编译运行\r\n\r\n```\r\n输入python saySleep.py\r\n	控制台显示以下内容\r\n		->	访问localhost:5000\r\n			->响应内容:	hello 《眠》\r\n```\r\n\r\n\r\n\r\n控制台\r\n\r\n```\r\nD:\\code\\PycharmProjects>python saySleep.py\r\n * Serving Flask app \"__name__\" (lazy loading)\r\n * Environment: production\r\n   WARNING: This is a development server. Do not use it in a production deployment.\r\n   Use a production WSGI server instead.\r\n * Debug mode: off\r\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\r\n```\r\n\r\n\r\n\r\n\r\n\r\n#### 三.路由\r\n\r\n类似controller的flask\r\n\r\napp.route可以像requestmapping一样绑定多个URL请求拦截, 像controller一样, 它也可以有多个app.route()\r\n\r\n###### 文件3-1:D:\\code\\PycharmProjects\\hellov2.py\r\n\r\n```python\r\nfrom flask import Flask\r\napp = Flask(__name__)\r\n\r\n@app.route(\'/\')\r\ndef hello():\r\n    return \'Hello Wor!\'\r\n\r\n@app.route(\'/index\')    \r\ndef index():\r\n    return \'index\'\r\n\r\nif __name__ == \'__main__\':\r\n    app.run(debug=True)\r\n```\r\n\r\n响应\r\n\r\n```\r\n访问localhost:5000\r\n	网页响应Hello Wor!\r\n访问localhost:5000/index		\r\n	网页响应index\r\n```\r\n\r\n\r\n\r\n#### 四.变量规则\r\n\r\n在URLt增加变量的部分\r\n\r\n比如: 在URL后增加参数的部分, 请求对应用户名的资料\r\n\r\n```python\r\nimport flask from Flask\r\napp = Flask(__name__)\r\n\r\n@app.route(\'/user/<username>\')\r\ndef show_user_profile(username):	#显示用户档案\r\n    return \'User %s\' % username	\r\n\r\n@app.route(\'/post/<int:post_id>\')	\r\ndef show_post(post_id):				#显示上传者id\r\n    return \'Post %d\' % post_id\r\n\r\nif __name==\'__main__\':\r\n    app.run()\r\n```\r\n\r\n转换器: `converter:var_name` \r\n\r\n表示URL中可接收的参数类型: int:post_id 表只接受整数类型的post_id\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 答疑\r\n\r\n##### 文档中说的\"这样, 就构成了我们第一个 WSGI程序\"\r\n\r\n其中的WSGI释义:服务器网关接口\r\n\r\n\r\n\r\n##### 打开debug模式有一个好处是\r\n\r\n可以让命令行也看见报错的日志.', '2021-04-26');
INSERT INTO `post` VALUES (55, 'Java', 'part04-flask模板', '', '# part04-flask模板\r\n\r\n[TOC]\r\n\r\n[参考文档](https://blog.csdn.net/sinat_38682860/article/details/103109242)\r\n\r\ntime: \r\n\r\n### 一.编写html\r\n\r\n##### 文件1-1:D:\\code\\PycharmProjects\\login.html\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">   \r\n    <title>html</title>\r\n</head>\r\n<body>\r\n    <h1>html</h1>\r\n</body>\r\n</html>\r\n```\r\n\r\n### 二.编写flask文件\r\n\r\n##### 文件2-1:D:\\code\\PycharmProjects\\helloWeb.py\r\n\r\n```python\r\nfrom flask import Flask,render_template\r\n\r\napp = Flask(__name__)\r\n\r\n@app.route(\'/\')\r\ndef index():\r\n    return render_template(\'login.html\')\r\n\r\nif __name__ == \"__main__\":\r\n    app.run(debug = True)\r\n```\r\n\r\n> 如果只是使用`return`, 就还是响应一串字符串\r\n>\r\n> 引用render_template, 然后使用render_template()\r\n\r\n### 三.启动并访问\r\n\r\n```\r\n地址栏: localhost:5000\r\n	网页响应 jinja2.exceptions.TemplateNotFound error\r\n	\r\n	解决方法:新建templates文件夹, 将 html.html 放在文件夹下\r\n		重启并访问\r\n			网页响应html网页中的内容\r\n解释: \r\nYou put your template in the wrong place. From the Flask docs:\r\nFlask will look for templates in the templates folder\r\n```\r\n\r\n[jinja2.exceptions.TemplateNotFound error](https://stackoverflow.com/questions/15053790/jinja2-exceptions-templatenotfound-error)\r\n\r\n\r\n\r\n### 问题出现的原因\r\n\r\n所以网页的跳转和重定向唯一必要引用的只有render_template依赖\r\n\r\nrender_template的跳转也和文件夹`templates`有联系\r\n\r\n也就是说 flask 默认会从项目下名叫 `templates` 的文件夹下去找网页. 即我们需要在项目下新建一个名为 `templates` 的文件夹, 然后再将前台页面放进去.\r\n\r\n文件1-1的实际路径: D:\\code\\PycharmProjects\\crud\\templates\\html.html\r\n\r\n出现问题解决不了的还是要想请教别人\r\n\r\n\r\n\r\n### Rendering Template(响应模板)\r\n\r\n```\r\n/application\r\n	/helloWeb.py\r\n	/templates\r\n		/html.html\r\n```\r\n\r\n', '2021-04-26');
INSERT INTO `post` VALUES (56, 'Python', 'part04-flask模板', '', '# part04-flask模板\r\n\r\n[TOC]\r\n\r\n[参考文档](https://blog.csdn.net/sinat_38682860/article/details/103109242)\r\n\r\ntime: \r\n\r\n### 一.编写html\r\n\r\n##### 文件1-1:D:\\code\\PycharmProjects\\login.html\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">   \r\n    <title>html</title>\r\n</head>\r\n<body>\r\n    <h1>html</h1>\r\n</body>\r\n</html>\r\n```\r\n\r\n### 二.编写flask文件\r\n\r\n##### 文件2-1:D:\\code\\PycharmProjects\\helloWeb.py\r\n\r\n```python\r\nfrom flask import Flask,render_template\r\n\r\napp = Flask(__name__)\r\n\r\n@app.route(\'/\')\r\ndef index():\r\n    return render_template(\'login.html\')\r\n\r\nif __name__ == \"__main__\":\r\n    app.run(debug = True)\r\n```\r\n\r\n> 如果只是使用`return`, 就还是响应一串字符串\r\n>\r\n> 引用render_template, 然后使用render_template()\r\n\r\n### 三.启动并访问\r\n\r\n```\r\n地址栏: localhost:5000\r\n	网页响应 jinja2.exceptions.TemplateNotFound error\r\n	\r\n	解决方法:新建templates文件夹, 将 html.html 放在文件夹下\r\n		重启并访问\r\n			网页响应html网页中的内容\r\n解释: \r\nYou put your template in the wrong place. From the Flask docs:\r\nFlask will look for templates in the templates folder\r\n```\r\n\r\n[jinja2.exceptions.TemplateNotFound error](https://stackoverflow.com/questions/15053790/jinja2-exceptions-templatenotfound-error)\r\n\r\n\r\n\r\n### 问题出现的原因\r\n\r\n所以网页的跳转和重定向唯一必要引用的只有render_template依赖\r\n\r\nrender_template的跳转也和文件夹`templates`有联系\r\n\r\n也就是说 flask 默认会从项目下名叫 `templates` 的文件夹下去找网页. 即我们需要在项目下新建一个名为 `templates` 的文件夹, 然后再将前台页面放进去.\r\n\r\n文件1-1的实际路径: D:\\code\\PycharmProjects\\crud\\templates\\html.html\r\n\r\n出现问题解决不了的还是要想请教别人\r\n\r\n\r\n\r\n### Rendering Template(响应模板)\r\n\r\n```\r\n/application\r\n	/helloWeb.py\r\n	/templates\r\n		/html.html\r\n```\r\n\r\n', '2021-04-26');
INSERT INTO `post` VALUES (57, 'Python', 'part05-变量', '', '# part05-变量\r\n\r\n[TOC]\r\n\r\n要义: 如何向网页中传递一个变量显示\r\n\r\n### 一.编写html文件\r\n\r\n##### 文件1-1:D:\\code\\PycharmProjects\\crud\\templates\\html.html\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>{{title}}</title>\r\n</head>\r\n<body>\r\n    <h1>hello, {{user.username}}!</h1>\r\n</body>\r\n</html>\r\n```\r\n\r\n> title和user.username两个变量\r\n\r\n### 二.编写flask文件\r\n\r\n##### 文件2-1:D:\\code\\PycharmProjects\\crud\\helloWeb.py\r\n\r\n```python\r\nfrom flask import Flask,render_template\r\n\r\napp = Flask(__name__)\r\n\r\n@app.route(\'/\')\r\ndef index():        \r\n    return render_template(\'html.html\')\r\n\r\nif __name__ == \"__main__\":\r\n    app.run(debug = True)\r\n```\r\n\r\n\r\n\r\n### 三.启动并访问\r\n\r\n```\r\npython helloWeb.py\r\n	此时网页会显示jinja2.exceptions.UndefinedError: \'user\' is undefined\r\n	user未定义\r\n	如果网页中有定义{{变量}}的话, flask会检测到的, 必须得定义\r\n```\r\n\r\n### 四.编写flask文件\r\n\r\n##### 文件2-1:D:\\code\\PycharmProjects\\crud\\helloWeb.py\r\n\r\n```python\r\nfrom flask import Flask,render_template\r\n\r\napp = Flask(__name__)\r\n\r\n@app.route(\'/\')\r\ndef index():   \r\n    #在这一行定义\r\n    user = {\'username\': \'Miguel\'}\r\n    return render_template(\'html.html\', title=\'Home\', user=user)\r\n	#其它值也在其中定义, 对象user必须单独定义\r\n\r\nif __name__ == \"__main__\":\r\n    app.run(debug = True)\r\n```\r\n\r\n#### 五.启动并访问\r\n\r\n```\r\npython helloWeb.py\r\n	此时网页会显示 hello, Miguel!\r\n```\r\n\r\n', '2021-04-26');
INSERT INTO `post` VALUES (58, 'Python', '用flask开发一个小程序后台服务器', '', '# 用flask开发一个小程序后台服务器\r\n\r\n[TOC]\r\n\r\n**后台部分**\r\n\r\n#### 1.搭建flask后台\r\n\r\n```python\r\nfrom flask import Flask\r\n\r\napp = Flask(__name__)   #Flask的构造函数, 传入__name__确定根目录的位置\r\n\r\n@app.route(\'/doPycharm\')\r\ndef doPychatm():\r\n    return \"你好, 我是小程序后台\"	#返回给小程序的数据\r\n\r\nif __name__==\"__main__\":\r\n    app.run(host=\'0.0.0.0\', debug=True)\r\n```\r\n\r\n\r\n\r\n**小程序部分**\r\n\r\n#### 2.定义小程序前端页面-index.wxml\r\n\r\n```html\r\n<!--index.wxml-->\r\n<view>  \r\n  <button bindtap=\"toPycharm\">访问后台数据</button> 	<!--1.1-->\r\n  <text>{{echo}}</text>  							<!--1.2-->\r\n</view>\r\n\r\n```\r\n\r\n> 1.1.定义toPycharm点击事件\r\n>\r\n> 1.2.定义echo用来绑定并显示数据\r\n\r\n\r\n\r\n#### 3.定义函数绑定页面-index.js\r\n\r\n```js\r\n//index.js\r\n//获取应用实例\r\nconst app = getApp()\r\n\r\nPage({\r\n  data: {\r\n    echo: \'\'			//2.1\r\n  },\r\n  //请求后台数据\r\n  toPycharm: function() {\r\n    let that=this\r\n    wx.request({\r\n      url: \'http://127.0.0.1:5000/doPycharm\',	//	2.2\r\n      success(res) {							//	2.3\r\n        console.log(\"数据保存成功\", res) \r\n        that.setData({\r\n          echo:res.data\r\n        })       \r\n      }\r\n    })\r\n  }\r\n});\r\n```\r\n\r\n> 2.1.声明echo变量\r\n>\r\n> 2.2.url表该函数请求的url\r\n>\r\n> 2.3.加入成功后在控制台输出并绑定变量值\r\n\r\n#### 4.接下来启动服务器\r\n\r\n```\r\npython helloUni.py\r\n\r\nD:\\code\\PycharmProjects\\uni>python helloUni.py\r\n * Serving Flask app \"helloUni\" (lazy loading)\r\n * Environment: production\r\n   WARNING: This is a development server. Do not use it in a production deployment.\r\n   Use a production WSGI server instead.\r\n * Debug mode: on\r\n * Restarting with stat\r\n * Debugger is active!\r\n * Debugger PIN: 328-520-404\r\n * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)\r\n	\r\n启动成功后, 小程序点击请求\r\n	此时会显示url不合法, ∵小程序不允许和本地IP通信\r\n可以在微信开发者的设置一栏中, 找到\'不校验合法域名和https证书\'	\r\n这样, 报错就会变成提醒\r\n\r\n此时, 点击请求按钮, 下方就会出现\"你好, 我是小程序后台\"\r\n	控制台也会显示\r\n数据保存成功 \r\n{data: \"你好, 我是小程序后台\", header: {…}, statusCode: 200, cookies: Array(0), errMsg: \"request:ok\"}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n#### 须留意\r\n\r\n微信小程序官方规定: \r\n\r\n```\r\n每个微信小程序需要事先设置通讯域名，小程序只可以跟指定的域名进行网络通信。包括普通 HTTPS 请求（wx.request）、上传文件（wx.uploadFile）、下载文件（wx.downloadFile) 和 WebSocket 通信（wx.connectSocket）。\r\n从基础库 2.4.0 开始，网络接口允许与局域网 IP 通信，但要注意 不允许与本机 IP 通信。\r\n从 2.7.0 开始，提供了 UDP 通信（wx.createUDPSocket)。\r\n```\r\n\r\n在开发者的设置中勾选不校验合法域名即可避免这一情况.\r\n\r\n> 经过本文实验, 以下url均可正常请求\r\n>\r\n> http://127.0.0.1:5000/doPycharm\r\n>\r\n> http://localhost:5000/doPycharm\r\n\r\n\r\n\r\n> 小程序和其它语言写的后台之间交互的秘密', '2021-04-26');
INSERT INTO `post` VALUES (59, 'Python', 'part07-flask表单', '', '# part07-flask表单\r\n\r\n[TOC]\r\n\r\n[参考Youtube-Get Form Checkbox Data in Flask With .getlist](https://www.youtube.com/watch?v=_sgVt16Q4O4)\r\n\r\n\r\n\r\n### 一.前台表单\r\n\r\n##### 文件1-1: flask-web/templates/checkbox.html\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>表单</title>\r\n</head>\r\n<body>\r\n    <form method=\"POST\" action=\"/form\">\r\n        Checkbox1: <input type=\"checkbox\" value=\"1\" name=\"myCheckbox\"/>\r\n        Checkbox2: <input type=\"checkbox\" value=\"2\" name=\"myCheckbox\"/>\r\n        Checkbox3: <input type=\"checkbox\" value=\"3\" name=\"myCheckbox\"/>\r\n        Checkbox4: <input type=\"checkbox\" value=\"4\" name=\"myCheckbox\"/>\r\n        <input type=\"submit\" value=\"Submit\"/>\r\n    </form>\r\n</body>\r\n</html>\r\n```\r\n\r\n> 一组带值的 checkbox\r\n\r\n\r\n\r\n### 二.后台\r\n\r\n导入 `request` 利用 `request.form.get() ` 拿到表单\r\n\r\n##### 文件2-1: flask-web/flask-form.py\r\n\r\n```python\r\nfrom flask import Flask, render_template, request\r\n\r\napp = Flask(__name__)\r\n\r\n@app.route(\'/form\', methods=[\'GET\', \'POST\'])\r\ndef checkbox():\r\n    if request.method == \'POST\':\r\n        print(request.form.get(\'myCheckbox\'))\r\n        return \'Done\'\r\n    return render_template(\'checkbox.html\')\r\n\r\nif __name__ == \'__main__\':\r\n    app.run(debug=True)\r\n```\r\n\r\n\r\n\r\n### 访问\r\n\r\n##### localhost:5000/form\r\n\r\n```\r\n1.来到 checkbox.html(因为控制器指定返回这个页面)\r\n	2.勾选任意一个或几个 checkbox 并提交\r\n		结果: 控制台出现勾选的 checkbox 带的值\r\n		\r\n127.0.0.1 - - [11/Mar/2021 16:57:55] \"?[37mGET /form HTTP/1.1?[0m\" 200 -\r\n1\r\n表单数据获取成功\r\n```\r\n\r\n\r\n\r\n> Q: 为什么勾选了多个却只显示一个值?\r\n>\r\n> A: get() 方法只能存放一个值, 若勾选多个有且只拿第一个值; 如果要拿一组值, 请用 getlist()\r\n\r\n\r\n\r\n### 应用: 获取多个表单值\r\n\r\n修改 flask-form.py 中的一行代码\r\n\r\n```python\r\nprint(request.form.get(\'myCheckbox\'))\r\n# 改成\r\nprint(request.form.getlist(\'myCheckbox\'))\r\n```\r\n\r\n保证程序启动, 重新访问并勾选 1-3 并提交\r\n\r\n```\r\n结果\r\n	控制台出现一组值\r\n127.0.0.1 - - [11/Mar/2021 17:04:10] \"?[37mGET /form HTTP/1.1?[0m\" 200 -\r\n[\'1\', \'2\', \'3\']\r\n成功获取多个值\r\n```\r\n\r\n\r\n\r\n### 扩展\r\n\r\n已经知道了如果通过 `request` 获取表单的值, 将表单换成正式的登录页也是类似\r\n\r\n\r\n\r\n### 一.前台\r\n\r\n##### 文件1-1: flask-web/templates/login.html\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>表单</title>\r\n</head>\r\n<body>\r\n    <form method=\"POST\" action=\"/login\">\r\n        username: <input type=\"text\" name=\"username\"/>\r\n        password: <input type=\"password\" name=\"pwd\"/>\r\n        <input type=\"submit\" value=\"Submit\"/>\r\n    </form>\r\n</body>\r\n</html>\r\n```\r\n\r\n##### 文件1-2: flask-web/templates/login-result.html\r\n\r\n> 页面放 2 个变量, 用于返回表单填入的数据, 验证表单数据获取(不输出到控制台了)\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>login表单结果</title>\r\n</head>\r\n<body>\r\n    你在刚才的表单中填写的数据是:\r\n    {{ username }}\r\n    {{ password }}\r\n</body>\r\n</html>\r\n```\r\n\r\n\r\n\r\n### 后台\r\n\r\n##### 文件3-1: flask-web/flask-form.py\r\n\r\n```python\r\nfrom flask import Flask, render_template, request\r\n\r\napp = Flask(__name__)\r\n\r\n#获取 login 表单数据并返回 login-result.html 显示拿到的数据\r\n@app.route(\'/login\', methods=[\'GET\', \'POST\'])\r\ndef login():\r\n    if request.method == \'POST\':        \r\n        username = request.form.get(\'username\')\r\n        # 另一种方法, 更通用(还适用于获取小程序端的表单)\r\n        # request.form[\'username\']\r\n        password = request.form.get(\'pwd\')\r\n        return render_template(\'login-result.html\', username=username, password=password)\r\n    return render_template(\'login.html\')\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    app.run(debug=True)\r\n```\r\n\r\n\r\n\r\n### 验证\r\n\r\n```\r\n启动应用并访问 localhost:5000/login\r\n	来到 login.html 并任意填写数据  1231 23\r\n	提交后标签页跳转到 login-result.html 的标签信息\r\n	页面显示 \r\n	你在刚才的表单中填写的数据是: 1231 23\r\n	说明表单数据获取并返回成功\r\n\r\n```\r\n\r\n\r\n\r\n### 认识Flask\r\n\r\n通过这一 part, 主要知道 Flask 通过 `request` 去获取前台表单的数据.	\r\n\r\n\r\n\r\n参考:\r\n\r\n[Creeper-flask mysqldb Code Example - code grepper](https://www.codegrepper.com/code-examples/whatever/flask+mysqldb)\r\n\r\n', '2021-04-26');
INSERT INTO `post` VALUES (60, 'Python', 'part08-连接数据库', '', '# part08-连接数据库\r\n\r\n[TOC]\r\n\r\n### 一.安装Module `flask-mysqldb`\r\n\r\n```\r\n打开命令行(管理员)运行 pip install flask-mysqldb\r\n	显示\'Successfully installed flask-mysqldb-0.2.0 mysqlclient-2.0.3\'即表示安装成功\r\n```\r\n\r\n### 二.打开MySQL提前创建好数据库`flask_db`\r\n\r\n```\r\n(省略连接..)\r\nmysql>create database flask_db;\r\nQuery OK, 1 row affected (0.00 sec)\r\n```\r\n\r\n\r\n\r\n### 三.编写flask程序 `hellodb.py`建表\r\n\r\n```python\r\nfrom flask import Flask\r\nfrom flask_mysqldb import MySQL				#导入\r\n\r\napp = Flask(__name__)\r\n\r\napp.config[\'MYSQL_USER\'] = \'root\'			#数据库连接的变量\r\napp.config[\'MYSQL_PASSWORD\'] = \'root\'\r\napp.config[\'MYSQL_HOST\'] = \'localhost\'\r\napp.config[\'MYSQL_DB\'] = \'flask_db\'\r\napp.config[\'MYSQL_CUSORCLASS\'] = \'DictCursor\'\r\n\r\nmysql = MySQL(app)							#初始化\r\n\r\n@app.route(\'/\')\r\ndef users():\r\n    cur = mysql.connection.cursor()			#cursor\r\n    cur.execute(\'\'\'create table example(id INTEGER, name VARCHAR(20))\'\'\')	#建表\r\n    return \"Done!\"							#执行后在网页显示done\r\n\r\nif __name__ == \'__main__\':\r\n    app.run(debug=True)\r\n```\r\n\r\n\r\n\r\n### 四.启动并访问\r\n\r\n```\r\npython hellodb.py\r\n	 * Serving Flask app \"hellodb\" (lazy loading)\r\n     * Environment: production\r\n       WARNING: This is a development server. Do not use it in a production deployment.\r\n       Use a production WSGI server instead.\r\n     * Debug mode: on\r\n     * Restarting with stat\r\n     * Debugger is active!\r\n     * Debugger PIN: 328-520-404\r\n     * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\r\n浏览器访问localhost:5000\r\n	Done!\r\n命令行端查看数据表	\r\n	mysql> use flask_db\r\n    Database changed\r\n    mysql> show tables;\r\n    +--------------------+\r\n    | Tables_in_flask_db |\r\n    +--------------------+\r\n    | example            |\r\n    +--------------------+\r\n    1 row in set (0.00 sec)\r\n    数据库表创建成功!\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 补充(插入数据)\r\n\r\n插入数据\r\n\r\n### 一.注释掉建表并增加插入语句\r\n\r\n```python\r\nfrom flask import Flask\r\nfrom flask_mysqldb import MySQL\r\n\r\napp = Flask(__name__)\r\n\r\napp.config[\'MYSQL_USER\'] = \'root\'\r\napp.config[\'MYSQL_PASSWORD\'] = \'root\'\r\napp.config[\'MYSQL_HOST\'] = \'localhost\'\r\napp.config[\'MYSQL_DB\'] = \'flask_db\'\r\napp.config[\'MYSQL_CUSORCLASS\'] = \'DictCursor\'\r\n\r\nmysql = MySQL(app)\r\n\r\n@app.route(\'/\')\r\ndef users():\r\n    cur = mysql.connection.cursor()\r\n    #cur.execute(\'\'\'create table example(id INTEGER, name VARCHAR(20))\'\'\')\r\n    cur.execute(\'\'\'INSERT INTO example VALUES (1, \'Anthony\')\'\'\')\r\n    cur.execute(\'\'\'INSERT INTO example VALUES (2, \'Billy\')\'\'\')\r\n    #mysql的update/delete/insert需要加一步commit\r\n    mysql.connection.commit()\r\n    return \"Done!\"\r\n\r\nif __name__ == \'__main__\':\r\n    app.run(debug=True)\r\n```\r\n\r\n### 二.启动并访问\r\n\r\n```\r\n同样是在当前目录下执行python hellodb.py\r\n	启动服务器后访问localhost:5000\r\n	Done!\r\n打开命令行查看flask_db库的example表验证\r\n\r\nmysql> use flask_db\r\nDatabase changed\r\nmysql> select * from example\r\n    -> ;\r\n+------+---------+\r\n| id   | name    |\r\n+------+---------+\r\n|    1 | Anthony |\r\n|    2 | Billy   |\r\n+------+---------+\r\n2 rows in set (0.00 sec)	\r\n数据插入成功	\r\n```\r\n\r\n\r\n\r\n## 补充(查询数据)\r\n\r\n### a.改写flask程序\r\n\r\n注释掉插入语句, 增加查询语句, 并使用fetchall将所有的查询结果放进result中, 最后将result进行控制台打印\r\n\r\n```python\r\nfrom flask import Flask\r\nfrom flask_mysqldb import MySQL\r\n\r\napp = Flask(__name__)\r\n\r\napp.config[\'MYSQL_USER\'] = \'root\'\r\napp.config[\'MYSQL_PASSWORD\'] = \'root\'\r\napp.config[\'MYSQL_HOST\'] = \'localhost\'\r\napp.config[\'MYSQL_DB\'] = \'flask_db\'\r\napp.config[\'MYSQL_CUSORCLASS\'] = \'DictCursor\'\r\n\r\nmysql = MySQL(app)\r\n\r\n@app.route(\'/\')\r\ndef users():\r\n    cur = mysql.connection.cursor()\r\n    #cur.execute(\'\'\'create table example(id INTEGER, name VARCHAR(20))\'\'\')\r\n    #(\'\'\'INSERT INTO example VALUES (1, \'Anthony\')\'\'\')\r\n    #cur.execute(\'\'\'INSERT INTO example VALUES (2, \'Billy\')\'\'\')\r\n    #mysql的update/delete/insert需要加一步commit\r\n    #mysql.connection.commit()\r\n\r\n    cur.execute(\'\'\'SELECT * FROM example\'\'\')\r\n    #使用fetchall将所有的查询结果放进result\r\n    results = cur.fetchall()\r\n    print(results)\r\n\r\n    return \"Done!\"\r\n\r\nif __name__ == \'__main__\':\r\n    app.run(debug=True)\r\n```\r\n\r\n### b.启动应用并访问\r\n\r\n```\r\n操作步骤..\r\n浏览器端显示\r\n	Done!\r\n控制台端显示\r\n	 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\r\n	((1, \'Anthony\'), (2, \'Billy\'))\r\n	127.0.0.1 - - [22/Feb/2021 20:32:31] \"?[37mGET / HTTP/1.1?[0m\" 200 -\r\n	查询成功\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### (改装)return显示查询对象\r\n\r\n```python\r\n...\r\nreturn results[1][1]	//	Billy\r\nreturn result[0][1]		//	Anthony\r\nreturn result[0][0]		//	The return type must be a string, dict, tuple, Response instance, or WSGI callable, but it was a int.(返回值不能为int)\r\nreturn result[0][\'name\']	//	tuple indices must be integers or slices, not str(元组索引必须是整数而不能是字符串)\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 参考\r\n\r\n[Connecting to a MySQL Database in Flask Using Flask-MySQLDB (2019)-Youtube](https://www.youtube.com/watch?v=51F_frStZCQ)\r\n\r\n', '2021-04-26');
INSERT INTO `post` VALUES (62, 'Java', 'Java16-线程', '本文总结了有关线程部分的学习笔记', '[TOC]\r\n\r\n#### 简介\r\n\r\n之前的学习中, 一直以来都是只有一条顺序执行流. \r\n\r\n程序总是从 main() 方法开始执行, 依次向下执行每行代码(在调试中表现更为形象).\r\n\r\n\r\n\r\n> `Thread.currentThread()`\r\n>\r\n> 可获取当前执行线程\r\n>\r\n> `getName()`\r\n>\r\n> 返回线程的对象名\r\n\r\nMainTest\r\n\r\n```java\r\npackage chap16.thread;\r\n\r\n/**\r\n * @name  MainTest\r\n * @package chap16.thread\r\n * @intro	Thread.currentThread().getName()\r\n * @function	\r\n * */\r\npublic class MainTest {\r\n	\r\n	public static void run() {\r\n		System.out.println(Thread.currentThread().getName());\r\n	}\r\n	\r\n	public static void main(String[] args) {\r\n		System.out.println(Thread.currentThread().getName());\r\n		run();\r\n	}\r\n}\r\n```\r\n\r\n输出\r\n\r\n```\r\nmain\r\nmain\r\n```\r\n\r\n调用 `run()` 方法也是在 `main` 线程执行的一部分.\r\n\r\n这就是正常程序执行的流程\r\n\r\n由于总是从 `main()` 线程开始, 也总是到 `main()` 线程结束.\r\n\r\n\r\n\r\n#### 2 条线程\r\n\r\n```java\r\npublic class TestThread1 extends Thread {\r\n\r\n	@Override\r\n	public void run() {\r\n		//run()方法线程体\r\n		for (int i = 0; i < 5; i++) {\r\n			System.out.println(\"run方法执行-我在看代码---\" + i);\r\n		}\r\n	}\r\n	\r\n	public static void main(String[] args) {\r\n		//main线程, 主线程\r\n		\r\n		//创建一个线程对象\r\n		TestThread1 testThread1 = new TestThread1();\r\n		\r\n		//调用start()方法启动线程\r\n		testThread1.start();	//两条线程同时执行\r\n		\r\n		//main()方法线程体\r\n		for (int i= 0; i < 5; i++) {\r\n			System.out.println(\"main方法执行-我在学习多线程中\");\r\n		}\r\n	}\r\n}\r\n```\r\n\r\n简介\r\n\r\n```\r\n继承 Thread 在 main()方法中创建一个线程对象, 并调用start()方法启动线程\r\n```\r\n\r\n输出\r\n\r\n```\r\nmain方法执行-我在学习多线程中\r\nrun方法执行-我在看代码---0\r\nrun方法执行-我在看代码---1\r\nrun方法执行-我在看代码---2\r\nmain方法执行-我在学习多线程中\r\nmain方法执行-我在学习多线程中\r\nrun方法执行-我在看代码---3\r\nrun方法执行-我在看代码---4\r\n```\r\n\r\n(执行次数不同执行结果也各不相同)\r\n\r\n说明\r\n\r\n```\r\nstart() 启动线程后是run线程和main主线程 **2** 条线程在执行\r\n结果是线程异步性的结果\r\n上述的每一行都是 CPU 在不同的时间点打印的\r\n却都是在同一个时间段内执行的\r\n```\r\n\r\n\r\n\r\n#### 线程的创建和启动\r\n\r\n1. 继承 `Thread` 重写 `run()` 方法(线程执行体)\r\n2. 创建线程类对象\r\n3. 调用 `start() `方法启动线程\r\n\r\n\r\n\r\n#### 3 条线程的例子\r\n\r\n在 `main` 主线程中连续创建 2 个线程实例并启动 `start` 方法\r\n\r\n```java\r\npublic class FirstThread extends Thread {\r\n\r\n	private int i;\r\n	\r\n	@Override\r\n	public void run() {\r\n		for (; i<5; i++) {\r\n			//调用 getName() 获取线程的名字\r\n			System.out.println(getName() + \" \" + i);\r\n		}\r\n	}\r\n	\r\n	public static void main(String[] args) {\r\n		for (int i = 0; i < 10; i++) {\r\n			\r\n			System.out.println(Thread.currentThread().getName() + \" \" + i);\r\n			if (i == 9) {\r\n				//当 i 增长到 9 的时候开始创建并启动第一条线程\r\n				new FirstThread().start();\r\n				//创建并启动第二条线程\r\n				new FirstThread().start();\r\n			}\r\n		}		\r\n	}\r\n}\r\n```\r\n\r\n输出\r\n\r\n前 9 条打印结果是 main \r\n\r\n从第 9 条开始往下 Thread-n 就不连续了, 打印的是 Thread-0 和 Thread-1 穿插的结果, 一共会有 10 条.\r\n\r\n```\r\nmain 0\r\nmain 1\r\nmain 2\r\nmain 3\r\nmain 4\r\nmain 5\r\nmain 6\r\nmain 7\r\nmain 8\r\nmain 9\r\nThread-1 0\r\nThread-0 0\r\nThread-0 1\r\nThread-1 1\r\nThread-1 2\r\nThread-1 3\r\nThread-0 2\r\nThread-1 4\r\nThread-0 3\r\nThread-0 4\r\n```\r\n\r\n', '2021-05-14');
INSERT INTO `post` VALUES (63, 'others', '一个标题', '一条描述', '# 标题\r\n这里是内容', '2021-05-16');
INSERT INTO `post` VALUES (64, 'Java', '测试文章', '', '文章的内容xxx', '2021-05-16');

SET FOREIGN_KEY_CHECKS = 1;
